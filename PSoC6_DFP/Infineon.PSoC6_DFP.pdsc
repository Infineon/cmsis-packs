<?xml version="1.0" encoding="utf-8"?>
<package schemaVersion="1.6.0" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="PACK.xsd">
  <vendor>Infineon</vendor>
  <name>PSoC6_DFP</name>
  <description>Infineon PSoC 6 Device Support</description>
  <url>https://github.com/Infineon/cmsis-packs/raw/master/PSoC6_DFP/</url>
  <supportContact>https://www.infineon.com/support</supportContact>
  <license>APACHE_LICENSE.txt</license>
  <releases>
    <release version="1.4.0" date="2022-08-09">
      - Read and print target device information.
      - Fixed JTAG initialization problems.
    </release>
    <release version="1.3.0" date="2022-05-16">
      - The vendor name and DeviceVendorEnum was changed from Cypress to Infineon.
      - Added SFDP support for external memory programming.
      - Updated PSoCâ„¢ 6 CMSIS Flash Loaders to v4.1.0.559: bugfixes, performance and stability improvements.
    </release>
  </releases>
  <keywords>
    <keyword>Infineon</keyword>
    <keyword>PSoC 6</keyword>
    <keyword>DFP</keyword>
  </keywords>
  <devices>
    <!-- PSoC 60 -->
    <family Dfamily="PSoC 60" Dvendor="Infineon:7">
      <processor Pname="Cortex-M4" Dcore="Cortex-M4" DcoreVersion="r0p1" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="120000000" />
      <description>PSoC 60 (Value Line): Cortex-M4 MCU series with integrated analog and digital peripherals.</description>
      <book name="README.txt" title="Infineon PSoC 6 DFP user guide" />
      <book name="known_issues.txt" title="Infineon PSoC 6 DFP known issues" />
      <debug Pname="Cortex-M4" __ap="2" defaultResetSequence="ResetSystem">
        <datapatch address="0xE008EFE0" value="0x000000A1" info="this is Cortex-M4 TPIU, not Cortex-M3 TPIU. Debuggers may determine by this that TPIU supports Half-Frame Syncs." />
      </debug>
      <sequences>
        <sequence name="DAP_Handshake">
          <!-- DAP_Handshake: Execute initial handshake sequence depend on selected protocol -->
          <block>
            __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
            __var protType   = __protocol &amp; 0x0000FFFF;
            __var DPIDR = 0;
            __Result = 0;
          </block>
          <!-- JTAG Protocol -->
          <control if="protType == 1">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                DAP_SWJ_Sequence(16, 0xE73C);
              </block>
            </control>
            <block atomic="true">
              // JTAG "Soft" Reset
              DAP_JTAG_Sequence(6, 1, 0x00);                        // Test-Logic-Reset
              // Get IDCODE to make shure that JTAG-DP is available
              DAP_JTAG_Sequence(4, 0, 0x00);                        // 4*Run-Test/Idle
              DAP_JTAG_Sequence(2, 1, 0x00);                        // ~ Select-DR ~ Select-IR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-IR ~ Shift-IR
              DAP_JTAG_Sequence(8, 0, 0xFE);                        // Shift-IR (IDCODE BYPASS)
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-IR (IDCODE BYPASS) ~ Update-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
              DAP_JTAG_Sequence(1, 1, 0x00);                        // Select-DR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-DR ~ Shift-DR
              DPIDR = DAP_JTAG_Sequence(33, 0, 0x00000000);         // Shift 33-bits data
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-DR ~ Update-DR ~ ~ Select-DR ~ Select-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
            </block>
          </control>
          <!-- SWD Protocol -->
          <control if="protType == 2">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E)
                // Change if SWJ-DP uses deprecated switch code (0xEDB6)
                DAP_SWJ_Sequence(16, 0xE79E);
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <control if="!isSWJ">
              <block atomic="true">
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <block>
              DPIDR = ReadDP(0x0); // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
            </block>
          </control>
          <control if="(DPIDR &amp; 0xFFF00FFF) != 0x6BA00477">
            <block>
              __Result = -1; // DAP is unavailable
            </block>
          </control>
        </sequence>
        <sequence name="DAP_poll">
          <!-- DAP_poll: Poll the DAP until it becomes available -->
          <block>
            __Result = -1; // Assume DAP is not available yet
          </block>
          <control while="__Result != 0" timeout="600000">
            <block>
              sequence("DAP_Handshake"); // Poll DP until bootloader allows access to device (can be up to 600ms)
            </block>
          </control>
          <control if="__Result != 0">
            <block>
              Message(1, "The Debug Access Port is unavailable.");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortSetup">
          <!-- DebugPortSetup: Prepare the target debug port for connection -->
          <block>
            sequence("DAP_Handshake");
          </block>
          <control if="__Result != 0">
            <!-- In case DAP isn't avalable, execute a system-wide reset via dedicated debugger reset line. -->
            <block>
              __var nReset      = 0x80;
              __var canReadPins = 0;
              canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
            </block>
            <!-- Keep reset active for 50 ms -->
            <control while="1" timeout="50000" />
            <control if="canReadPins">
              <!-- Assert nRESET line and wait max. 1s for recovery -->
              <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
            </control>
            <control if="!canReadPins">
              <block>
                DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
              </block>
              <!-- Wait 100ms for recovery if nRESET not readable -->
              <control while="1" timeout="100000" />
            </control>
            <block>
              sequence("DAP_poll");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortStart">
          <!-- DebugPortStart: Connect to the target debug port and power it up -->
          <block info="Read DP CTRL/STAT">
            __var SW_DP_ABORT  = 0x0;
            __var DP_CTRL_STAT = 0x4;
            __var DP_SELECT    = 0x8;
            __var powered_down = 0;
            // Switch to DP Register Bank 0. Explicitly set APSEL to current AP selection
            WriteDP(DP_SELECT, __ap &lt;&lt; 24);
            // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
            powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
          </block>
          <control if="powered_down">
            <block info="Power Up System &amp; Debug">
              // Request Debug/System Power-Up
              // Ignore error here: even there is a polling in the next block, CMSIS-DAP transports reads DP.RDBUFF register
              // right after write to DP.CTRL_STAT. This will fail for some cases - for example if device is waking from DeepSleep.
              __errorcontrol = 1;
              WriteDP(DP_CTRL_STAT, 0x50000000);
              __errorcontrol = 0;
            </block>
            <!-- Wait for Power-Up Request to be acknowledged -->
            <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000" info="Wait for power acknowledged" />
            <!-- CDBGRSTREQ on PSoC6 behaves like Power-On Reset. Not desired when starting the Debug Port
            <block info="Debug Reset">
              __errorcontrol = 1;
              // Request Debug Reset
              WriteDP(DP_CTRL_STAT, 0x54000000);
              // CDBGRSTREQ is equivalent to Power-On Reset and fully reboots the device.
              // Depending on the user application the reboot can take up to 600ms.
              DAP_Delay(600000);
              __errorcontrol = 0;
            </block>
            -->
            <!-- Wait for Debug Reset to be acknowledged, don't issue error on timeout to deal with improperly connected Debug Reset -->
            <!-- <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA8000000) != 0xA8000000" timeout="300000" info="Wait for Debug Reset Acknowledge"/> -->
            <!-- JTAG Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 1">
              <block info="JTAG: Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                WriteDP(DP_CTRL_STAT, 0x50000F32);
              </block>
            </control>
            <!-- SWD Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 2">
              <block info="SWD: Init SWD &amp; Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                WriteDP(DP_CTRL_STAT, 0x50000F00);
                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                WriteDP(SW_DP_ABORT, 0x0000001E);
              </block>
            </control>
          </control>
          <block>
            Sequence("PrintDeviceInfo"); // Print device info
          </block>
        </sequence>
        <sequence name="ResetHardware">
          <!-- ResetHardware: HW Reset causes a reboot of the device which also resets debug.
               - Using this as a prereset is OK to potentially wake up the system from DeepSleep.
               - Using this in the middle of the debug session will break the connection unless recovery
                 from a connection loss is supported by the debug IDE.
          -->
          <block>
            __var nReset      = 0x80;
            __var canReadPins = 0;
            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
          </block>
          <!-- Keep reset active for 50 ms -->
          <control while="1" timeout="50000" />
          <control if="canReadPins">
            <!-- Assert nRESET line and wait max. 1s for recovery -->
            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
          </control>
          <control if="!canReadPins">
            <block>
              DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
            </block>
            <!-- Wait 100ms for recovery if nRESET not readable -->
            <control while="1" timeout="100000" />
          </control>
          <block>
            // Give the PSoC6 bootloader time to finish (can be up to 600ms)
            DAP_Delay(600000);
          </block>
        </sequence>
        <sequence name="PrintDeviceInfo">
          <!-- PrintDeviceInfo: Read and print device info -->
          <block>
            __var siId;
            __var siRev;
            __var siFamily;
            __var fbVerHi;
            __var sflashSvnVer;
            __var protection;
            __var v;
            Message(0, "****************************************************");
            // Get Si Id, Family and Rev.
            v = Read32(0x16000000);
            siId = (v &amp; 0xFFFF0000) &gt;&gt; 16;
            siRev = (v &amp; 0x0000FF00) &gt;&gt; 8;
            v = Read32(0x1600000C);
            siFamily = v &amp; 0x00000FFF;
            Message(0, "** Silicon: 0x%04X, Family: 0x%03X, Rev.: 0x%02X", siId, siFamily, siRev);
            // Get FlashBboot verison
            fbVerHi = Read32(0x16002004);
          </block>
          <control if="fbVerHi == 0">
            <block>
              Message(1, "Invalid FlashBoot: High version word of Flash Boot is zero");
            </block>
          </control>
          <control if="fbVerHi != 0">
            <block>
              __var fbVerLo = Read32(0x16002018);
              __var b0 = fbVerHi &gt;&gt; 28;
              __var b1 = (fbVerHi &gt;&gt; 24) &amp; 0x0F;
              __var b2 = (fbVerHi &gt;&gt; 16) &amp; 0xFF;
              __var b3 = fbVerHi &amp; 0x0000FFFF;
            </block>
            <control if="b0 &gt; 2">
              <block>
                Message(1, "Unsupported Flash Boot Version - Flash Boot Version [31:28] = 0x%X", b0);
              </block>
            </control>
            <control if="b0 &lt;= 2">
              <control if="b3 != 0x8001">
                <block>
                  Message(1, "Flash Boot is corrupted or non Flash Boot image programmed");
                </block>
              </control>
              <control if="b3 == 0x8001">
                <control if="b0 == 0">
                  <control if="b1 == 1">
                    <block>
                      Message(0, "** Flash Boot version: 1.%02u", b2);
                    </block>
                  </control>
                  <control if="b1 == 2">
                    <control if="b2 &lt; 20">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.0.%u", b2);
                      </block>
                    </control>
                    <control if="(b2 &gt;= 20) &amp;&amp; (b2 &lt; 29)">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.1.%u", b2);
                      </block>
                    </control>
                    <control if="b2 &gt;= 29">
                      <block>
                        Message(0, "** Flash Boot version: 1.20.1.%u", b2);
                      </block>
                    </control>
                  </control>
                </control>
                <control if="b0 == 1">
                  <block>
                    Message(0, "** Flash Boot version: 2.0.0.%u", b2);
                  </block>
                </control>
                <control if="b0 == 2">
                  <block>
                    __var patch = fbVerLo &gt;&gt; 24;
                    __var build = fbVerLo &amp; 0x0000FFFF;
                    Message(0, "** Flash Boot version: %u.%u.%u.%u", b1, b2, patch, build);
                  </block>
                </control>
              </control>
            </control>
          </control>
          <block>
            sflashSvnVer = Read32(0x16000028); // Get SFLASH version
          </block>
          <control if="(sflashSvnVer != 0) &amp;&amp; (sflashSvnVer != 0xFFFFFFFF)">
            <block>
              Message(0, "** SFlash version: %u", sflashSvnVer);
            </block>
          </control>
          <!-- Get life-cycle stage -->
          <control if="siFamily == 0x100">
            <block>
              protection = Read32(0x40210500); // PSoC 6-BLE2 family
            </block>
          </control>
          <control if="siFamily != 0x100">
            <block>
              protection = Read32(0x402020C4); // PSoC 6-2M family
            </block>
          </control>
          <!-- Decode life-cycle stage -->
          <control if="protection == 1">
            <block>
              Message(0, "** Chip Protection: VIRGIN");
            </block>
          </control>
          <control if="protection == 2">
            <block>
              Message(0, "** Chip Protection: NORMAL");
            </block>
          </control>
          <control if="protection == 3">
            <block>
              Message(0, "** Chip Protection: SECURE");
            </block>
          </control>
          <control if="protection == 4">
            <block>
              Message(0, "** Chip Protection: DEAD");
            </block>
          </control>
          <control if="(protection == 0) || (protection &gt; 4)">
            <block>
              Message(0, "** Chip Protection: UNKNOWN");
            </block>
          </control>
          <block>
            Message(0, "****************************************************");
          </block>
        </sequence>
        <sequence name="DebugCoreStart" Pname="Cortex-M4">
          <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
          <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
          <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
            <block>
              Sequence("SetupTraceClock");
            </block>
          </control>
        </sequence>
        <!-- Configure pins trace pins if Parallel Trace Port enabled -->
        <sequence name="TraceStart" Pname="Cortex-M4">
          <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
            <block>
              __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
            </block>
            <control if="__TPIU_pinlocation == 1" info="CY8CKIT-062-WIFI-BT Like">
              <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
              <control if="tpWidth &gt;= 1">
                <block>
                  sequence("SetupTracePin_P7_6");
                </block>
              </control>
              <control if="tpWidth &gt;= 2">
                <block>
                  sequence("SetupTracePin_P7_5");
                  sequence("SetupTracePin_P7_4");
                </block>
              </control>
            </control>
            <control if="__TPIU_pinlocation == 2" info="CY8CKIT-062S2-43012 Like">
              <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
              <control if="tpWidth &gt;= 1">
                <block>
                  sequence("SetupTracePin_P9_2");
                </block>
              </control>
              <control if="tpWidth &gt;= 2">
                <block>
                  sequence("SetupTracePin_P9_1");
                  sequence("SetupTracePin_P9_0");
                </block>
              </control>
            </control>
          </control>
        </sequence>
        <sequence name="SetupTraceClock" Pname="Cortex-M4">
          <block>
            __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;    // PERI_CLOCK_CTL.DIV_SEL
            __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;       // ENABLE field in PERI_DIV_CMD
            __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;      // DISABLE field in PERI_DIV_CMD
            // Peripheral clock divider index to use for trace clock
            __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
            __var ClockDivVal = 0 &amp; PERI_DIV_PA_SEL_MASK;  // Peripheral clock divider value for trace clock
                                                               // Actual divider is (1+ClockDivVal)
            __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
            __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
          </block>
          <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
            <block>
              Message(0, "Setup TPIU clock");
              // DISABLE 8.0 DIV in PERI_DIV_CMD:
              __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              // Use selected divider (8.0) for cpuss.clock_trace_in
              Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
              // Set 8.0 DIV = ClockDivVal
              Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
              // ENABLE 8.0 DIV
              ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_0 as TRACECLK -->
        <sequence name="SetupTracePin_P7_0" Pname="Cortex-M4">
          <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1A;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P7_0)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACECLK to P7_0");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_4 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P7_4" Pname="Cortex-M4">
          <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P7_4");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_5 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P7_5" Pname="Cortex-M4">
          <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P7_5");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_6 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P7_6" Pname="Cortex-M4">
          <block>
            __var pin = 6;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P7_6");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_0 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P9_0" Pname="Cortex-M4">
          <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P9_0");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_1 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P9_1" Pname="Cortex-M4">
          <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P9_1");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_2 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P9_2" Pname="Cortex-M4">
          <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P9_2");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_3 as TRACEDATA[0]  -->
        <sequence name="SetupTracePin_P9_3" Pname="Cortex-M4">
          <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[0] to P9_3");
            </block>
          </control>
        </sequence>
      </sequences>
      <!-- PSoC 60, CY8C60x6 -->
      <subFamily DsubFamily="CY8C60x6">
        <debug Pname="Cortex-M4" svd="SVD/psoc6_01.svd" />
        <debugvars configfile="Debug/CY8C6xx7.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 1;                      // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40010CD8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40010800;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40010400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 1M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000000FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000008;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V1
          __var hsiomPrt7PortSel0Addr = 0x40310070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40310090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403203A8;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403204A8;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403203B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403204B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00020000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00080000" default="1" startup="1" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6016BZI-F04">
          <compile define="CY8C6016BZI_F04" />
        </device>
        <device Dname="CY8C6036BZI-F04">
          <compile define="CY8C6036BZI_F04" />
        </device>
      </subFamily>
    </family>
    <!-- PSoC 61 -->
    <family Dfamily="PSoC 61" Dvendor="Infineon:7">
      <processor Pname="Cortex-M4" Dcore="Cortex-M4" DcoreVersion="r0p1" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="150000000" />
      <description>PSoC 61 (Programmable Line): Cortex-M4 MCU series with programmable digital and analog peripherals, CapSense and crypto security.</description>
      <book name="README.txt" title="Infineon PSoC 6 DFP user guide" />
      <book name="known_issues.txt" title="Infineon PSoC 6 DFP known issues" />
      <debug Pname="Cortex-M4" __ap="2" defaultResetSequence="ResetSystem">
        <datapatch address="0xE008EFE0" value="0x000000A1" info="this is Cortex-M4 TPIU, not Cortex-M3 TPIU. Debuggers may determine by this that TPIU supports Half-Frame Syncs." />
      </debug>
      <sequences>
        <sequence name="DAP_Handshake">
          <!-- DAP_Handshake: Execute initial handshake sequence depend on selected protocol -->
          <block>
            __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
            __var protType   = __protocol &amp; 0x0000FFFF;
            __var DPIDR = 0;
            __Result = 0;
          </block>
          <!-- JTAG Protocol -->
          <control if="protType == 1">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                DAP_SWJ_Sequence(16, 0xE73C);
              </block>
            </control>
            <block atomic="true">
              // JTAG "Soft" Reset
              DAP_JTAG_Sequence(6, 1, 0x00);                        // Test-Logic-Reset
              // Get IDCODE to make shure that JTAG-DP is available
              DAP_JTAG_Sequence(4, 0, 0x00);                        // 4*Run-Test/Idle
              DAP_JTAG_Sequence(2, 1, 0x00);                        // ~ Select-DR ~ Select-IR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-IR ~ Shift-IR
              DAP_JTAG_Sequence(8, 0, 0xFE);                        // Shift-IR (IDCODE BYPASS)
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-IR (IDCODE BYPASS) ~ Update-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
              DAP_JTAG_Sequence(1, 1, 0x00);                        // Select-DR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-DR ~ Shift-DR
              DPIDR = DAP_JTAG_Sequence(33, 0, 0x00000000);         // Shift 33-bits data
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-DR ~ Update-DR ~ ~ Select-DR ~ Select-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
            </block>
          </control>
          <!-- SWD Protocol -->
          <control if="protType == 2">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E)
                // Change if SWJ-DP uses deprecated switch code (0xEDB6)
                DAP_SWJ_Sequence(16, 0xE79E);
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <control if="!isSWJ">
              <block atomic="true">
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <block>
              DPIDR = ReadDP(0x0); // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
            </block>
          </control>
          <control if="(DPIDR &amp; 0xFFF00FFF) != 0x6BA00477">
            <block>
              __Result = -1; // DAP is unavailable
            </block>
          </control>
        </sequence>
        <sequence name="DAP_poll">
          <!-- DAP_poll: Poll the DAP until it becomes available -->
          <block>
            __Result = -1; // Assume DAP is not available yet
          </block>
          <control while="__Result != 0" timeout="600000">
            <block>
              sequence("DAP_Handshake"); // Poll DP until bootloader allows access to device (can be up to 600ms)
            </block>
          </control>
          <control if="__Result != 0">
            <block>
              Message(1, "The Debug Access Port is unavailable.");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortSetup">
          <!-- DebugPortSetup: Prepare the target debug port for connection -->
          <block>
            sequence("DAP_Handshake");
          </block>
          <control if="__Result != 0">
            <!-- In case DAP isn't avalable, execute a system-wide reset via dedicated debugger reset line. -->
            <block>
              __var nReset      = 0x80;
              __var canReadPins = 0;
              canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
            </block>
            <!-- Keep reset active for 50 ms -->
            <control while="1" timeout="50000" />
            <control if="canReadPins">
              <!-- Assert nRESET line and wait max. 1s for recovery -->
              <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
            </control>
            <control if="!canReadPins">
              <block>
                DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
              </block>
              <!-- Wait 100ms for recovery if nRESET not readable -->
              <control while="1" timeout="100000" />
            </control>
            <block>
              sequence("DAP_poll");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortStart">
          <!-- DebugPortStart: Connect to the target debug port and power it up -->
          <block info="Read DP CTRL/STAT">
            __var SW_DP_ABORT  = 0x0;
            __var DP_CTRL_STAT = 0x4;
            __var DP_SELECT    = 0x8;
            __var powered_down = 0;
            // Switch to DP Register Bank 0. Explicitly set APSEL to current AP selection
            WriteDP(DP_SELECT, __ap &lt;&lt; 24);
            // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
            powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
          </block>
          <control if="powered_down">
            <block info="Power Up System &amp; Debug">
              // Request Debug/System Power-Up
              // Ignore error here: even there is a polling in the next block, CMSIS-DAP transports reads DP.RDBUFF register
              // right after write to DP.CTRL_STAT. This will fail for some cases - for example if device is waking from DeepSleep.
              __errorcontrol = 1;
              WriteDP(DP_CTRL_STAT, 0x50000000);
              __errorcontrol = 0;
            </block>
            <!-- Wait for Power-Up Request to be acknowledged -->
            <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000" info="Wait for power acknowledged" />
            <!-- CDBGRSTREQ on PSoC6 behaves like Power-On Reset. Not desired when starting the Debug Port
            <block info="Debug Reset">
              __errorcontrol = 1;
              // Request Debug Reset
              WriteDP(DP_CTRL_STAT, 0x54000000);
              // CDBGRSTREQ is equivalent to Power-On Reset and fully reboots the device.
              // Depending on the user application the reboot can take up to 600ms.
              DAP_Delay(600000);
              __errorcontrol = 0;
            </block>
            -->
            <!-- Wait for Debug Reset to be acknowledged, don't issue error on timeout to deal with improperly connected Debug Reset -->
            <!-- <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA8000000) != 0xA8000000" timeout="300000" info="Wait for Debug Reset Acknowledge"/> -->
            <!-- JTAG Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 1">
              <block info="JTAG: Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                WriteDP(DP_CTRL_STAT, 0x50000F32);
              </block>
            </control>
            <!-- SWD Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 2">
              <block info="SWD: Init SWD &amp; Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                WriteDP(DP_CTRL_STAT, 0x50000F00);
                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                WriteDP(SW_DP_ABORT, 0x0000001E);
              </block>
            </control>
          </control>
          <block>
            Sequence("PrintDeviceInfo"); // Print device info
          </block>
        </sequence>
        <sequence name="ResetHardware">
          <!-- ResetHardware: HW Reset causes a reboot of the device which also resets debug.
               - Using this as a prereset is OK to potentially wake up the system from DeepSleep.
               - Using this in the middle of the debug session will break the connection unless recovery
                 from a connection loss is supported by the debug IDE.
          -->
          <block>
            __var nReset      = 0x80;
            __var canReadPins = 0;
            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
          </block>
          <!-- Keep reset active for 50 ms -->
          <control while="1" timeout="50000" />
          <control if="canReadPins">
            <!-- Assert nRESET line and wait max. 1s for recovery -->
            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
          </control>
          <control if="!canReadPins">
            <block>
              DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
            </block>
            <!-- Wait 100ms for recovery if nRESET not readable -->
            <control while="1" timeout="100000" />
          </control>
          <block>
            // Give the PSoC6 bootloader time to finish (can be up to 600ms)
            DAP_Delay(600000);
          </block>
        </sequence>
        <sequence name="PrintDeviceInfo">
          <!-- PrintDeviceInfo: Read and print device info -->
          <block>
            __var siId;
            __var siRev;
            __var siFamily;
            __var fbVerHi;
            __var sflashSvnVer;
            __var protection;
            __var v;
            Message(0, "****************************************************");
            // Get Si Id, Family and Rev.
            v = Read32(0x16000000);
            siId = (v &amp; 0xFFFF0000) &gt;&gt; 16;
            siRev = (v &amp; 0x0000FF00) &gt;&gt; 8;
            v = Read32(0x1600000C);
            siFamily = v &amp; 0x00000FFF;
            Message(0, "** Silicon: 0x%04X, Family: 0x%03X, Rev.: 0x%02X", siId, siFamily, siRev);
            // Get FlashBboot verison
            fbVerHi = Read32(0x16002004);
          </block>
          <control if="fbVerHi == 0">
            <block>
              Message(1, "Invalid FlashBoot: High version word of Flash Boot is zero");
            </block>
          </control>
          <control if="fbVerHi != 0">
            <block>
              __var fbVerLo = Read32(0x16002018);
              __var b0 = fbVerHi &gt;&gt; 28;
              __var b1 = (fbVerHi &gt;&gt; 24) &amp; 0x0F;
              __var b2 = (fbVerHi &gt;&gt; 16) &amp; 0xFF;
              __var b3 = fbVerHi &amp; 0x0000FFFF;
            </block>
            <control if="b0 &gt; 2">
              <block>
                Message(1, "Unsupported Flash Boot Version - Flash Boot Version [31:28] = 0x%X", b0);
              </block>
            </control>
            <control if="b0 &lt;= 2">
              <control if="b3 != 0x8001">
                <block>
                  Message(1, "Flash Boot is corrupted or non Flash Boot image programmed");
                </block>
              </control>
              <control if="b3 == 0x8001">
                <control if="b0 == 0">
                  <control if="b1 == 1">
                    <block>
                      Message(0, "** Flash Boot version: 1.%02u", b2);
                    </block>
                  </control>
                  <control if="b1 == 2">
                    <control if="b2 &lt; 20">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.0.%u", b2);
                      </block>
                    </control>
                    <control if="(b2 &gt;= 20) &amp;&amp; (b2 &lt; 29)">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.1.%u", b2);
                      </block>
                    </control>
                    <control if="b2 &gt;= 29">
                      <block>
                        Message(0, "** Flash Boot version: 1.20.1.%u", b2);
                      </block>
                    </control>
                  </control>
                </control>
                <control if="b0 == 1">
                  <block>
                    Message(0, "** Flash Boot version: 2.0.0.%u", b2);
                  </block>
                </control>
                <control if="b0 == 2">
                  <block>
                    __var patch = fbVerLo &gt;&gt; 24;
                    __var build = fbVerLo &amp; 0x0000FFFF;
                    Message(0, "** Flash Boot version: %u.%u.%u.%u", b1, b2, patch, build);
                  </block>
                </control>
              </control>
            </control>
          </control>
          <block>
            sflashSvnVer = Read32(0x16000028); // Get SFLASH version
          </block>
          <control if="(sflashSvnVer != 0) &amp;&amp; (sflashSvnVer != 0xFFFFFFFF)">
            <block>
              Message(0, "** SFlash version: %u", sflashSvnVer);
            </block>
          </control>
          <!-- Get life-cycle stage -->
          <control if="siFamily == 0x100">
            <block>
              protection = Read32(0x40210500); // PSoC 6-BLE2 family
            </block>
          </control>
          <control if="siFamily != 0x100">
            <block>
              protection = Read32(0x402020C4); // PSoC 6-2M family
            </block>
          </control>
          <!-- Decode life-cycle stage -->
          <control if="protection == 1">
            <block>
              Message(0, "** Chip Protection: VIRGIN");
            </block>
          </control>
          <control if="protection == 2">
            <block>
              Message(0, "** Chip Protection: NORMAL");
            </block>
          </control>
          <control if="protection == 3">
            <block>
              Message(0, "** Chip Protection: SECURE");
            </block>
          </control>
          <control if="protection == 4">
            <block>
              Message(0, "** Chip Protection: DEAD");
            </block>
          </control>
          <control if="(protection == 0) || (protection &gt; 4)">
            <block>
              Message(0, "** Chip Protection: UNKNOWN");
            </block>
          </control>
          <block>
            Message(0, "****************************************************");
          </block>
        </sequence>
        <sequence name="DebugCoreStart" Pname="Cortex-M4">
          <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
          <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
          <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
            <block>
              Sequence("SetupTraceClock");
            </block>
          </control>
        </sequence>
        <!-- Configure pins trace pins if Parallel Trace Port enabled -->
        <sequence name="TraceStart" Pname="Cortex-M4">
          <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
            <block>
              __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
            </block>
            <control if="__TPIU_pinlocation == 1" info="CY8CKIT-062-WIFI-BT Like">
              <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
              <control if="tpWidth &gt;= 1">
                <block>
                  sequence("SetupTracePin_P7_6");
                </block>
              </control>
              <control if="tpWidth &gt;= 2">
                <block>
                  sequence("SetupTracePin_P7_5");
                  sequence("SetupTracePin_P7_4");
                </block>
              </control>
            </control>
            <control if="__TPIU_pinlocation == 2" info="CY8CKIT-062S2-43012 Like">
              <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
              <control if="tpWidth &gt;= 1">
                <block>
                  sequence("SetupTracePin_P9_2");
                </block>
              </control>
              <control if="tpWidth &gt;= 2">
                <block>
                  sequence("SetupTracePin_P9_1");
                  sequence("SetupTracePin_P9_0");
                </block>
              </control>
            </control>
          </control>
        </sequence>
        <sequence name="SetupTraceClock" Pname="Cortex-M4">
          <block>
            __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;    // PERI_CLOCK_CTL.DIV_SEL
            __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;       // ENABLE field in PERI_DIV_CMD
            __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;      // DISABLE field in PERI_DIV_CMD
            // Peripheral clock divider index to use for trace clock
            __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
            __var ClockDivVal = 0 &amp; PERI_DIV_PA_SEL_MASK;  // Peripheral clock divider value for trace clock
                                                               // Actual divider is (1+ClockDivVal)
            __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
            __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
          </block>
          <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
            <block>
              Message(0, "Setup TPIU clock");
              // DISABLE 8.0 DIV in PERI_DIV_CMD:
              __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              // Use selected divider (8.0) for cpuss.clock_trace_in
              Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
              // Set 8.0 DIV = ClockDivVal
              Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
              // ENABLE 8.0 DIV
              ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_0 as TRACECLK -->
        <sequence name="SetupTracePin_P7_0" Pname="Cortex-M4">
          <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1A;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P7_0)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACECLK to P7_0");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_4 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P7_4" Pname="Cortex-M4">
          <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P7_4");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_5 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P7_5" Pname="Cortex-M4">
          <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P7_5");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_6 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P7_6" Pname="Cortex-M4">
          <block>
            __var pin = 6;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P7_6");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_0 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P9_0" Pname="Cortex-M4">
          <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P9_0");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_1 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P9_1" Pname="Cortex-M4">
          <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P9_1");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_2 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P9_2" Pname="Cortex-M4">
          <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P9_2");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_3 as TRACEDATA[0]  -->
        <sequence name="SetupTracePin_P9_3" Pname="Cortex-M4">
          <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[0] to P9_3");
            </block>
          </control>
        </sequence>
      </sequences>
      <!-- PSoC 61, CY8C61x4 -->
      <subFamily DsubFamily="CY8C61x4">
        <debug Pname="Cortex-M4" svd="SVD/psoc6_04.svd" />
        <debugvars configfile="Debug/CY8C6xxA.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 2;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40000C54;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40001000;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40000400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x03;               // 512K devices have 4 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V2
          __var hsiomPrt7PortSel0Addr = 0x40300070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40300090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403103C4;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403104C4;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403103CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403104CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00020000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00040000" default="1" startup="1" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx4.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx4_sect128KB.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6144AZI-S4F12">
          <compile define="CY8C6144AZI_S4F12" />
        </device>
        <device Dname="CY8C6144AZI-S4F62">
          <compile define="CY8C6144AZI_S4F62" />
        </device>
        <device Dname="CY8C6144AZI-S4F82">
          <compile define="CY8C6144AZI_S4F82" />
        </device>
        <device Dname="CY8C6144AZI-S4F83">
          <compile define="CY8C6144AZI_S4F83" />
        </device>
        <device Dname="CY8C6144AZI-S4F92">
          <compile define="CY8C6144AZI_S4F92" />
        </device>
        <device Dname="CY8C6144AZI-S4F93">
          <compile define="CY8C6144AZI_S4F93" />
        </device>
        <device Dname="CY8C6144AZQ-S4F92">
          <compile define="CY8C6144AZQ_S4F92" />
        </device>
        <device Dname="CY8C6144AZQ-S4F93">
          <compile define="CY8C6144AZQ_S4F93" />
        </device>
        <device Dname="CY8C6144LQI-S4F12">
          <compile define="CY8C6144LQI_S4F12" />
        </device>
        <device Dname="CY8C6144LQI-S4F62">
          <compile define="CY8C6144LQI_S4F62" />
        </device>
        <device Dname="CY8C6144LQI-S4F82">
          <compile define="CY8C6144LQI_S4F82" />
        </device>
        <device Dname="CY8C6144LQI-S4F92">
          <compile define="CY8C6144LQI_S4F92" />
        </device>
        <device Dname="CY8C6144LQQ-S4F92">
          <compile define="CY8C6144LQQ_S4F92" />
        </device>
      </subFamily>
      <!-- PSoC 61, CY8C61x5 -->
      <subFamily DsubFamily="CY8C61x5">
        <debug Pname="Cortex-M4" svd="SVD/psoc6_03.svd" />
        <debugvars configfile="Debug/CY8C6xxA.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 2;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40000C5C;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40001000;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40000400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x03;               // 512K devices have 4 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V2
          __var hsiomPrt7PortSel0Addr = 0x40300070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40300090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403103C4;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403104C4;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403103CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403104CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00040000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00080000" default="1" startup="1" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx5.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx5_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6145AZI-S3F02">
          <compile define="CY8C6145AZI_S3F02" />
        </device>
        <device Dname="CY8C6145AZI-S3F12">
          <compile define="CY8C6145AZI_S3F12" />
        </device>
        <device Dname="CY8C6145AZI-S3F42">
          <compile define="CY8C6145AZI_S3F42" />
        </device>
        <device Dname="CY8C6145AZI-S3F62">
          <compile define="CY8C6145AZI_S3F62" />
        </device>
        <device Dname="CY8C6145AZI-S3F72">
          <compile define="CY8C6145AZI_S3F72" />
        </device>
        <device Dname="CY8C6145FNI-S3F11">
          <compile define="CY8C6145FNI_S3F11" />
        </device>
        <device Dname="CY8C6145FNI-S3F41">
          <compile define="CY8C6145FNI_S3F41" />
        </device>
        <device Dname="CY8C6145FNI-S3F71">
          <compile define="CY8C6145FNI_S3F71" />
        </device>
        <device Dname="CY8C6145LQI-S3F02">
          <compile define="CY8C6145LQI_S3F02" />
        </device>
        <device Dname="CY8C6145LQI-S3F12">
          <compile define="CY8C6145LQI_S3F12" />
        </device>
        <device Dname="CY8C6145LQI-S3F42">
          <compile define="CY8C6145LQI_S3F42" />
        </device>
        <device Dname="CY8C6145LQI-S3F62">
          <compile define="CY8C6145LQI_S3F62" />
        </device>
        <device Dname="CY8C6145LQI-S3F72">
          <compile define="CY8C6145LQI_S3F72" />
        </device>
      </subFamily>
      <!-- PSoC 61, CY8C61x6 -->
      <subFamily DsubFamily="CY8C61x6">
        <debug Pname="Cortex-M4" svd="SVD/psoc6_01.svd" />
        <debugvars configfile="Debug/CY8C6xx7.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 1;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40010CD8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40010800;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40010400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 1M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000000FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000008;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V1
          __var hsiomPrt7PortSel0Addr = 0x40310070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40310090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403203A8;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403204A8;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403203B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403204B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00020000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00080000" default="1" startup="1" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6116BZI-F54">
          <compile define="CY8C6116BZI_F54" />
        </device>
        <device Dname="CY8C6136BZI-F14">
          <compile define="CY8C6136BZI_F14" />
        </device>
        <device Dname="CY8C6136BZI-F34">
          <compile define="CY8C6136BZI_F34" />
        </device>
        <device Dname="CY8C6136FDI-F42">
          <compile define="CY8C6136FDI_F42" />
        </device>
        <device Dname="CY8C6136FTI-F42">
          <compile define="CY8C6136FTI_F42" />
        </device>
      </subFamily>
      <!-- PSoC 61, CY8C61x7 -->
      <subFamily DsubFamily="CY8C61x7">
        <debug Pname="Cortex-M4" svd="SVD/psoc6_01.svd" />
        <debugvars configfile="Debug/CY8C6xx7.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 1;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40010CD8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40010800;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40010400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 1M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000000FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000008;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V1
          __var hsiomPrt7PortSel0Addr = 0x40310070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40310090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403203A8;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403204A8;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403203B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403204B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00048000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00100000" default="1" startup="1" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx7.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx7_sect256KB.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6117BZI-F34">
          <compile define="CY8C6117BZI_F34" />
        </device>
        <device Dname="CY8C6117FDI-F02">
          <compile define="CY8C6117FDI_F02" />
        </device>
        <device Dname="CY8C6117WI-F34">
          <compile define="CY8C6117WI_F34" />
        </device>
        <device Dname="CY8C6137BZI-F14">
          <compile define="CY8C6137BZI_F14" />
        </device>
        <device Dname="CY8C6137BZI-F34">
          <compile define="CY8C6137BZI_F34" />
        </device>
        <device Dname="CY8C6137BZI-F54">
          <compile define="CY8C6137BZI_F54" />
        </device>
        <device Dname="CY8C6137FDI-F02">
          <compile define="CY8C6137FDI_F02" />
        </device>
        <device Dname="CY8C6137WI-F54">
          <compile define="CY8C6137WI_F54" />
        </device>
      </subFamily>
      <!-- PSoC 61, CY8C61x8 -->
      <subFamily DsubFamily="CY8C61x8">
        <debug Pname="Cortex-M4" svd="SVD/psoc6_02.svd" />
        <debugvars configfile="Debug/CY8C6xxA.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 2;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40000CC8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40001000;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40000400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 2M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V2
          __var hsiomPrt7PortSel0Addr = 0x40300070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40300090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403103C4;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403104C4;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403103CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403104CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00080000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00100000" default="1" startup="1" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx8.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx8_sect256KB.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6148AZI-S2F44">
          <compile define="CY8C6148AZI_S2F44" />
        </device>
        <device Dname="CY8C6148BZI-S2F44">
          <compile define="CY8C6148BZI_S2F44" />
        </device>
        <device Dname="CY8C6148FNI-S2F43">
          <compile define="CY8C6148FNI_S2F43" />
        </device>
        <device Dname="CY8C6148LQI-S2F02">
          <compile define="CY8C6148LQI_S2F02" />
        </device>
        <device Dname="CY8C6148LQI-S2F42">
          <compile define="CY8C6148LQI_S2F42" />
        </device>
      </subFamily>
      <!-- PSoC 61, CY8C61xA -->
      <subFamily DsubFamily="CY8C61xA">
        <debug Pname="Cortex-M4" svd="SVD/psoc6_02.svd" />
        <debugvars configfile="Debug/CY8C6xxA.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 2;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40000CC8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40001000;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40000400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 2M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V2
          __var hsiomPrt7PortSel0Addr = 0x40300070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40300090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403103C4;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403104C4;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403103CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403104CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00100000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00200000" default="1" startup="1" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA.FLM" start="0x10000000" size="0x00200000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_sect256KB.FLM" start="0x10000000" size="0x00200000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C614AAZI-S2F04">
          <compile define="CY8C614AAZI_S2F04" />
        </device>
        <device Dname="CY8C614AAZI-S2F14">
          <compile define="CY8C614AAZI_S2F14" />
        </device>
        <device Dname="CY8C614AAZI-S2F44">
          <compile define="CY8C614AAZI_S2F44" />
        </device>
        <device Dname="CY8C614ABZI-S2F04">
          <compile define="CY8C614ABZI_S2F04" />
        </device>
        <device Dname="CY8C614ABZI-S2F44">
          <compile define="CY8C614ABZI_S2F44" />
        </device>
        <device Dname="CY8C614AFNI-S2F03">
          <compile define="CY8C614AFNI_S2F03" />
        </device>
        <device Dname="CY8C614AFNI-S2F43">
          <compile define="CY8C614AFNI_S2F43" />
        </device>
        <device Dname="CY8C614ALQI-S2F02">
          <compile define="CY8C614ALQI_S2F02" />
        </device>
        <device Dname="CY8C614ALQI-S2F42">
          <compile define="CY8C614ALQI_S2F42" />
        </device>
      </subFamily>
    </family>
    <!-- PSoC 62 -->
    <family Dfamily="PSoC 62" Dvendor="Infineon:7">
      <processor Pname="Cortex-M0p" Dcore="Cortex-M0+" DcoreVersion="r0p1" Dfpu="NO_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="100000000" />
      <processor Pname="Cortex-M4" Dcore="Cortex-M4" DcoreVersion="r0p1" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="150000000" />
      <description>PSoC 62 (Performance Line): Dual-core Cortex-M4/M0+ MCU series with programmable digital and analog peripherals, advanced graphics, CapSense, crypto and secure boot security.</description>
      <book name="README.txt" title="Infineon PSoC 6 DFP user guide" />
      <book name="known_issues.txt" title="Infineon PSoC 6 DFP known issues" />
      <debug Pname="Cortex-M0p" __ap="1" defaultResetSequence="ResetProcessor" />
      <debug Pname="Cortex-M4" __ap="2" defaultResetSequence="ResetSystem">
        <datapatch address="0xE008EFE0" value="0x000000A1" info="this is Cortex-M4 TPIU, not Cortex-M3 TPIU. Debuggers may determine by this that TPIU supports Half-Frame Syncs." />
      </debug>
      <sequences>
        <sequence name="DAP_Handshake">
          <!-- DAP_Handshake: Execute initial handshake sequence depend on selected protocol -->
          <block>
            __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
            __var protType   = __protocol &amp; 0x0000FFFF;
            __var DPIDR = 0;
            __Result = 0;
          </block>
          <!-- JTAG Protocol -->
          <control if="protType == 1">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                DAP_SWJ_Sequence(16, 0xE73C);
              </block>
            </control>
            <block atomic="true">
              // JTAG "Soft" Reset
              DAP_JTAG_Sequence(6, 1, 0x00);                        // Test-Logic-Reset
              // Get IDCODE to make shure that JTAG-DP is available
              DAP_JTAG_Sequence(4, 0, 0x00);                        // 4*Run-Test/Idle
              DAP_JTAG_Sequence(2, 1, 0x00);                        // ~ Select-DR ~ Select-IR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-IR ~ Shift-IR
              DAP_JTAG_Sequence(8, 0, 0xFE);                        // Shift-IR (IDCODE BYPASS)
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-IR (IDCODE BYPASS) ~ Update-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
              DAP_JTAG_Sequence(1, 1, 0x00);                        // Select-DR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-DR ~ Shift-DR
              DPIDR = DAP_JTAG_Sequence(33, 0, 0x00000000);         // Shift 33-bits data
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-DR ~ Update-DR ~ ~ Select-DR ~ Select-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
            </block>
          </control>
          <!-- SWD Protocol -->
          <control if="protType == 2">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E)
                // Change if SWJ-DP uses deprecated switch code (0xEDB6)
                DAP_SWJ_Sequence(16, 0xE79E);
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <control if="!isSWJ">
              <block atomic="true">
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <block>
              DPIDR = ReadDP(0x0); // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
            </block>
          </control>
          <control if="(DPIDR &amp; 0xFFF00FFF) != 0x6BA00477">
            <block>
              __Result = -1; // DAP is unavailable
            </block>
          </control>
        </sequence>
        <sequence name="DAP_poll">
          <!-- DAP_poll: Poll the DAP until it becomes available -->
          <block>
            __Result = -1; // Assume DAP is not available yet
          </block>
          <control while="__Result != 0" timeout="600000">
            <block>
              sequence("DAP_Handshake"); // Poll DP until bootloader allows access to device (can be up to 600ms)
            </block>
          </control>
          <control if="__Result != 0">
            <block>
              Message(1, "The Debug Access Port is unavailable.");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortSetup">
          <!-- DebugPortSetup: Prepare the target debug port for connection -->
          <block>
            sequence("DAP_Handshake");
          </block>
          <control if="__Result != 0">
            <!-- In case DAP isn't avalable, execute a system-wide reset via dedicated debugger reset line. -->
            <block>
              __var nReset      = 0x80;
              __var canReadPins = 0;
              canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
            </block>
            <!-- Keep reset active for 50 ms -->
            <control while="1" timeout="50000" />
            <control if="canReadPins">
              <!-- Assert nRESET line and wait max. 1s for recovery -->
              <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
            </control>
            <control if="!canReadPins">
              <block>
                DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
              </block>
              <!-- Wait 100ms for recovery if nRESET not readable -->
              <control while="1" timeout="100000" />
            </control>
            <block>
              sequence("DAP_poll");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortStart">
          <!-- DebugPortStart: Connect to the target debug port and power it up -->
          <block info="Read DP CTRL/STAT">
            __var SW_DP_ABORT  = 0x0;
            __var DP_CTRL_STAT = 0x4;
            __var DP_SELECT    = 0x8;
            __var powered_down = 0;
            // Switch to DP Register Bank 0. Explicitly set APSEL to current AP selection
            WriteDP(DP_SELECT, __ap &lt;&lt; 24);
            // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
            powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
          </block>
          <control if="powered_down">
            <block info="Power Up System &amp; Debug">
              // Request Debug/System Power-Up
              // Ignore error here: even there is a polling in the next block, CMSIS-DAP transports reads DP.RDBUFF register
              // right after write to DP.CTRL_STAT. This will fail for some cases - for example if device is waking from DeepSleep.
              __errorcontrol = 1;
              WriteDP(DP_CTRL_STAT, 0x50000000);
              __errorcontrol = 0;
            </block>
            <!-- Wait for Power-Up Request to be acknowledged -->
            <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000" info="Wait for power acknowledged" />
            <!-- CDBGRSTREQ on PSoC6 behaves like Power-On Reset. Not desired when starting the Debug Port
            <block info="Debug Reset">
              __errorcontrol = 1;
              // Request Debug Reset
              WriteDP(DP_CTRL_STAT, 0x54000000);
              // CDBGRSTREQ is equivalent to Power-On Reset and fully reboots the device.
              // Depending on the user application the reboot can take up to 600ms.
              DAP_Delay(600000);
              __errorcontrol = 0;
            </block>
            -->
            <!-- Wait for Debug Reset to be acknowledged, don't issue error on timeout to deal with improperly connected Debug Reset -->
            <!-- <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA8000000) != 0xA8000000" timeout="300000" info="Wait for Debug Reset Acknowledge"/> -->
            <!-- JTAG Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 1">
              <block info="JTAG: Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                WriteDP(DP_CTRL_STAT, 0x50000F32);
              </block>
            </control>
            <!-- SWD Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 2">
              <block info="SWD: Init SWD &amp; Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                WriteDP(DP_CTRL_STAT, 0x50000F00);
                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                WriteDP(SW_DP_ABORT, 0x0000001E);
              </block>
            </control>
          </control>
          <block>
            Sequence("PrintDeviceInfo"); // Print device info
          </block>
        </sequence>
        <sequence name="ResetHardware">
          <!-- ResetHardware: HW Reset causes a reboot of the device which also resets debug.
               - Using this as a prereset is OK to potentially wake up the system from DeepSleep.
               - Using this in the middle of the debug session will break the connection unless recovery
                 from a connection loss is supported by the debug IDE.
          -->
          <block>
            __var nReset      = 0x80;
            __var canReadPins = 0;
            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
          </block>
          <!-- Keep reset active for 50 ms -->
          <control while="1" timeout="50000" />
          <control if="canReadPins">
            <!-- Assert nRESET line and wait max. 1s for recovery -->
            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
          </control>
          <control if="!canReadPins">
            <block>
              DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
            </block>
            <!-- Wait 100ms for recovery if nRESET not readable -->
            <control while="1" timeout="100000" />
          </control>
          <block>
            // Give the PSoC6 bootloader time to finish (can be up to 600ms)
            DAP_Delay(600000);
          </block>
        </sequence>
        <sequence name="PrintDeviceInfo">
          <!-- PrintDeviceInfo: Read and print device info -->
          <block>
            __var siId;
            __var siRev;
            __var siFamily;
            __var fbVerHi;
            __var sflashSvnVer;
            __var protection;
            __var v;
            Message(0, "****************************************************");
            // Get Si Id, Family and Rev.
            v = Read32(0x16000000);
            siId = (v &amp; 0xFFFF0000) &gt;&gt; 16;
            siRev = (v &amp; 0x0000FF00) &gt;&gt; 8;
            v = Read32(0x1600000C);
            siFamily = v &amp; 0x00000FFF;
            Message(0, "** Silicon: 0x%04X, Family: 0x%03X, Rev.: 0x%02X", siId, siFamily, siRev);
            // Get FlashBboot verison
            fbVerHi = Read32(0x16002004);
          </block>
          <control if="fbVerHi == 0">
            <block>
              Message(1, "Invalid FlashBoot: High version word of Flash Boot is zero");
            </block>
          </control>
          <control if="fbVerHi != 0">
            <block>
              __var fbVerLo = Read32(0x16002018);
              __var b0 = fbVerHi &gt;&gt; 28;
              __var b1 = (fbVerHi &gt;&gt; 24) &amp; 0x0F;
              __var b2 = (fbVerHi &gt;&gt; 16) &amp; 0xFF;
              __var b3 = fbVerHi &amp; 0x0000FFFF;
            </block>
            <control if="b0 &gt; 2">
              <block>
                Message(1, "Unsupported Flash Boot Version - Flash Boot Version [31:28] = 0x%X", b0);
              </block>
            </control>
            <control if="b0 &lt;= 2">
              <control if="b3 != 0x8001">
                <block>
                  Message(1, "Flash Boot is corrupted or non Flash Boot image programmed");
                </block>
              </control>
              <control if="b3 == 0x8001">
                <control if="b0 == 0">
                  <control if="b1 == 1">
                    <block>
                      Message(0, "** Flash Boot version: 1.%02u", b2);
                    </block>
                  </control>
                  <control if="b1 == 2">
                    <control if="b2 &lt; 20">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.0.%u", b2);
                      </block>
                    </control>
                    <control if="(b2 &gt;= 20) &amp;&amp; (b2 &lt; 29)">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.1.%u", b2);
                      </block>
                    </control>
                    <control if="b2 &gt;= 29">
                      <block>
                        Message(0, "** Flash Boot version: 1.20.1.%u", b2);
                      </block>
                    </control>
                  </control>
                </control>
                <control if="b0 == 1">
                  <block>
                    Message(0, "** Flash Boot version: 2.0.0.%u", b2);
                  </block>
                </control>
                <control if="b0 == 2">
                  <block>
                    __var patch = fbVerLo &gt;&gt; 24;
                    __var build = fbVerLo &amp; 0x0000FFFF;
                    Message(0, "** Flash Boot version: %u.%u.%u.%u", b1, b2, patch, build);
                  </block>
                </control>
              </control>
            </control>
          </control>
          <block>
            sflashSvnVer = Read32(0x16000028); // Get SFLASH version
          </block>
          <control if="(sflashSvnVer != 0) &amp;&amp; (sflashSvnVer != 0xFFFFFFFF)">
            <block>
              Message(0, "** SFlash version: %u", sflashSvnVer);
            </block>
          </control>
          <!-- Get life-cycle stage -->
          <control if="siFamily == 0x100">
            <block>
              protection = Read32(0x40210500); // PSoC 6-BLE2 family
            </block>
          </control>
          <control if="siFamily != 0x100">
            <block>
              protection = Read32(0x402020C4); // PSoC 6-2M family
            </block>
          </control>
          <!-- Decode life-cycle stage -->
          <control if="protection == 1">
            <block>
              Message(0, "** Chip Protection: VIRGIN");
            </block>
          </control>
          <control if="protection == 2">
            <block>
              Message(0, "** Chip Protection: NORMAL");
            </block>
          </control>
          <control if="protection == 3">
            <block>
              Message(0, "** Chip Protection: SECURE");
            </block>
          </control>
          <control if="protection == 4">
            <block>
              Message(0, "** Chip Protection: DEAD");
            </block>
          </control>
          <control if="(protection == 0) || (protection &gt; 4)">
            <block>
              Message(0, "** Chip Protection: UNKNOWN");
            </block>
          </control>
          <block>
            Message(0, "****************************************************");
          </block>
        </sequence>
        <sequence name="DebugCoreStart" Pname="Cortex-M4">
          <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
          <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
          <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
            <block>
              Sequence("SetupTraceClock");
            </block>
          </control>
        </sequence>
        <!-- Configure pins trace pins if Parallel Trace Port enabled -->
        <sequence name="TraceStart" Pname="Cortex-M4">
          <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
            <block>
              __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
            </block>
            <control if="__TPIU_pinlocation == 1" info="CY8CKIT-062-WIFI-BT Like">
              <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
              <control if="tpWidth &gt;= 1">
                <block>
                  sequence("SetupTracePin_P7_6");
                </block>
              </control>
              <control if="tpWidth &gt;= 2">
                <block>
                  sequence("SetupTracePin_P7_5");
                  sequence("SetupTracePin_P7_4");
                </block>
              </control>
            </control>
            <control if="__TPIU_pinlocation == 2" info="CY8CKIT-062S2-43012 Like">
              <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
              <control if="tpWidth &gt;= 1">
                <block>
                  sequence("SetupTracePin_P9_2");
                </block>
              </control>
              <control if="tpWidth &gt;= 2">
                <block>
                  sequence("SetupTracePin_P9_1");
                  sequence("SetupTracePin_P9_0");
                </block>
              </control>
            </control>
          </control>
        </sequence>
        <sequence name="SetupTraceClock" Pname="Cortex-M4">
          <block>
            __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;    // PERI_CLOCK_CTL.DIV_SEL
            __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;       // ENABLE field in PERI_DIV_CMD
            __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;      // DISABLE field in PERI_DIV_CMD
            // Peripheral clock divider index to use for trace clock
            __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
            __var ClockDivVal = 0 &amp; PERI_DIV_PA_SEL_MASK;  // Peripheral clock divider value for trace clock
                                                               // Actual divider is (1+ClockDivVal)
            __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
            __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
          </block>
          <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
            <block>
              Message(0, "Setup TPIU clock");
              // DISABLE 8.0 DIV in PERI_DIV_CMD:
              __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              // Use selected divider (8.0) for cpuss.clock_trace_in
              Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
              // Set 8.0 DIV = ClockDivVal
              Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
              // ENABLE 8.0 DIV
              ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_0 as TRACECLK -->
        <sequence name="SetupTracePin_P7_0" Pname="Cortex-M4">
          <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1A;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P7_0)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACECLK to P7_0");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_4 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P7_4" Pname="Cortex-M4">
          <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P7_4");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_5 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P7_5" Pname="Cortex-M4">
          <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P7_5");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_6 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P7_6" Pname="Cortex-M4">
          <block>
            __var pin = 6;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P7_6");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_0 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P9_0" Pname="Cortex-M4">
          <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P9_0");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_1 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P9_1" Pname="Cortex-M4">
          <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P9_1");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_2 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P9_2" Pname="Cortex-M4">
          <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P9_2");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_3 as TRACEDATA[0]  -->
        <sequence name="SetupTracePin_P9_3" Pname="Cortex-M4">
          <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[0] to P9_3");
            </block>
          </control>
        </sequence>
      </sequences>
      <!-- PSoC 62, CY8C62x4 -->
      <subFamily DsubFamily="CY8C62x4">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_04.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_04.svd" />
        <debugvars configfile="Debug/CY8C6xxA.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 2;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40000C54;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40001000;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40000400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x03;               // 512K devices have 4 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V2
          __var hsiomPrt7PortSel0Addr = 0x40300070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40300090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403103C4;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403104C4;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403103CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403104CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40201000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
          <sequence name="ResetSystem" Pname="Cortex-M0p">
            <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x40201120);
            vtBase = vtBase &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; ((vtBase &amp; 0xFFFF0000) != 0xFFFF0000);
          </block>
            <control if="appValid">
              <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
              <control if="resetAddress">
                <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);
                
                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);
                
                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;
                
                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);
                
                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
              </block>
                <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
                <block>
                __errorcontrol = 0;
              </block>
              </control>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00020000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00040000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx4.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx4_sect128KB.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx4.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx4_sect128KB.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6244AZI-S4D12">
          <compile define="CY8C6244AZI_S4D12" />
        </device>
        <device Dname="CY8C6244AZI-S4D62">
          <compile define="CY8C6244AZI_S4D62" />
        </device>
        <device Dname="CY8C6244AZI-S4D82">
          <compile define="CY8C6244AZI_S4D82" />
        </device>
        <device Dname="CY8C6244AZI-S4D83">
          <compile define="CY8C6244AZI_S4D83" />
        </device>
        <device Dname="CY8C6244AZI-S4D92">
          <compile define="CY8C6244AZI_S4D92" />
        </device>
        <device Dname="CY8C6244AZI-S4D93">
          <compile define="CY8C6244AZI_S4D93" />
        </device>
        <device Dname="CY8C6244AZQ-S4D92">
          <compile define="CY8C6244AZQ_S4D92" />
        </device>
        <device Dname="CY8C6244AZQ-S4D93">
          <compile define="CY8C6244AZQ_S4D93" />
        </device>
        <device Dname="CY8C6244LQI-S4D12">
          <compile define="CY8C6244LQI_S4D12" />
        </device>
        <device Dname="CY8C6244LQI-S4D62">
          <compile define="CY8C6244LQI_S4D62" />
        </device>
        <device Dname="CY8C6244LQI-S4D82">
          <compile define="CY8C6244LQI_S4D82" />
        </device>
        <device Dname="CY8C6244LQI-S4D92">
          <compile define="CY8C6244LQI_S4D92" />
        </device>
        <device Dname="CY8C6244LQQ-S4D92">
          <compile define="CY8C6244LQQ_S4D92" />
        </device>
      </subFamily>
      <!-- PSoC 62, CY8C62x5 -->
      <subFamily DsubFamily="CY8C62x5">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_03.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_03.svd" />
        <debugvars configfile="Debug/CY8C6xxA.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 2;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40000C5C;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40001000;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40000400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x03;               // 512K devices have 4 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V2
          __var hsiomPrt7PortSel0Addr = 0x40300070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40300090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403103C4;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403104C4;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403103CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403104CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40201000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
          <sequence name="ResetSystem" Pname="Cortex-M0p">
            <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x40201120);
            vtBase = vtBase &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; ((vtBase &amp; 0xFFFF0000) != 0xFFFF0000);
          </block>
            <control if="appValid">
              <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
              <control if="resetAddress">
                <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);
                
                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);
                
                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;
                
                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);
                
                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
              </block>
                <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
                <block>
                __errorcontrol = 0;
              </block>
              </control>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00040000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00080000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx5.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx5_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx5.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx5_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6245AZI-S3D02">
          <compile define="CY8C6245AZI_S3D02" />
        </device>
        <device Dname="CY8C6245AZI-S3D12">
          <compile define="CY8C6245AZI_S3D12" />
        </device>
        <device Dname="CY8C6245AZI-S3D42">
          <compile define="CY8C6245AZI_S3D42" />
        </device>
        <device Dname="CY8C6245AZI-S3D62">
          <compile define="CY8C6245AZI_S3D62" />
        </device>
        <device Dname="CY8C6245AZI-S3D72">
          <compile define="CY8C6245AZI_S3D72" />
        </device>
        <device Dname="CY8C6245FNI-S3D11">
          <compile define="CY8C6245FNI_S3D11" />
        </device>
        <device Dname="CY8C6245FNI-S3D41">
          <compile define="CY8C6245FNI_S3D41" />
        </device>
        <device Dname="CY8C6245FNI-S3D71">
          <compile define="CY8C6245FNI_S3D71" />
        </device>
        <device Dname="CY8C6245LQI-S3D02">
          <compile define="CY8C6245LQI_S3D02" />
        </device>
        <device Dname="CY8C6245LQI-S3D12">
          <compile define="CY8C6245LQI_S3D12" />
        </device>
        <device Dname="CY8C6245LQI-S3D42">
          <compile define="CY8C6245LQI_S3D42" />
        </device>
        <device Dname="CY8C6245LQI-S3D62">
          <compile define="CY8C6245LQI_S3D62" />
        </device>
        <device Dname="CY8C6245LQI-S3D72">
          <compile define="CY8C6245LQI_S3D72" />
        </device>
      </subFamily>
      <!-- PSoC 62, CY8C62x6 -->
      <subFamily DsubFamily="CY8C62x6">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_01.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_01.svd" />
        <debugvars configfile="Debug/CY8C6xx7.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 1;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40010CD8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40010800;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40010400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 1M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000000FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000008;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V1
          __var hsiomPrt7PortSel0Addr = 0x40310070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40310090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403203A8;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403204A8;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403203B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403204B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40210000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
          <sequence name="ResetSystem" Pname="Cortex-M0p">
            <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x402102B0);
            vtBase = vtBase &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; ((vtBase &amp; 0xFFFF0000) != 0xFFFF0000);
          </block>
            <control if="appValid">
              <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
              <control if="resetAddress">
                <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);
                
                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);
                
                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;
                
                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);
                
                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
              </block>
                <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
                <block>
                __errorcontrol = 0;
              </block>
              </control>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00020000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00080000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx6.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx6_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6246BZI-D04">
          <compile define="CY8C6246BZI_D04" />
        </device>
      </subFamily>
      <!-- PSoC 62, CY8C62x7 -->
      <subFamily DsubFamily="CY8C62x7">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_01.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_01.svd" />
        <debugvars configfile="Debug/CY8C6xx7.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 1;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40010CD8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40010800;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40010400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 1M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000000FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000008;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V1
          __var hsiomPrt7PortSel0Addr = 0x40310070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40310090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403203A8;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403204A8;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403203B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403204B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40210000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
          <sequence name="ResetSystem" Pname="Cortex-M0p">
            <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x402102B0);
            vtBase = vtBase &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; ((vtBase &amp; 0xFFFF0000) != 0xFFFF0000);
          </block>
            <control if="appValid">
              <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
              <control if="resetAddress">
                <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);
                
                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);
                
                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;
                
                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);
                
                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
              </block>
                <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
                <block>
                __errorcontrol = 0;
              </block>
              </control>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00048000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00100000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx7.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx7_sect256KB.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx7.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx7_sect256KB.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6247BFI-D54">
          <compile define="CY8C6247BFI_D54" />
        </device>
        <device Dname="CY8C6247BZI-AUD54">
          <compile define="CY8C6247BZI_AUD54" />
        </device>
        <device Dname="CY8C6247BZI-D34">
          <compile define="CY8C6247BZI_D34" />
        </device>
        <device Dname="CY8C6247BZI-D44">
          <compile define="CY8C6247BZI_D44" />
        </device>
        <device Dname="CY8C6247BZI-D54">
          <compile define="CY8C6247BZI_D54" />
        </device>
        <device Dname="CY8C6247FDI-D02">
          <compile define="CY8C6247FDI_D02" />
        </device>
        <device Dname="CY8C6247FDI-D32">
          <compile define="CY8C6247FDI_D32" />
        </device>
        <device Dname="CY8C6247FDI-D52">
          <compile define="CY8C6247FDI_D52" />
        </device>
        <device Dname="CY8C6247FTI-D52">
          <compile define="CY8C6247FTI_D52" />
        </device>
        <device Dname="CY8C6247WI-D54">
          <compile define="CY8C6247WI_D54" />
        </device>
      </subFamily>
      <!-- PSoC 62, CY8C62x8 -->
      <subFamily DsubFamily="CY8C62x8">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_02.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_02.svd" />
        <debugvars configfile="Debug/CY8C6xxA.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 2;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40000CC8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40001000;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40000400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 2M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V2
          __var hsiomPrt7PortSel0Addr = 0x40300070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40300090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403103C4;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403104C4;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403103CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403104CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40201000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
          <sequence name="ResetSystem" Pname="Cortex-M0p">
            <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x40201120);
            vtBase = vtBase &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; ((vtBase &amp; 0xFFFF0000) != 0xFFFF0000);
          </block>
            <control if="appValid">
              <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
              <control if="resetAddress">
                <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);
                
                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);
                
                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;
                
                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);
                
                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
              </block>
                <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
                <block>
                __errorcontrol = 0;
              </block>
              </control>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00080000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00100000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx8.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx8_sect256KB.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx8.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx8_sect256KB.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6248AZI-S2D14">
          <compile define="CY8C6248AZI_S2D14" />
        </device>
        <device Dname="CY8C6248AZI-S2D44">
          <compile define="CY8C6248AZI_S2D44" />
        </device>
        <device Dname="CY8C6248BZI-S2D44">
          <compile define="CY8C6248BZI_S2D44" />
        </device>
        <device Dname="CY8C6248FNI-S2D43">
          <compile define="CY8C6248FNI_S2D43" />
        </device>
        <device Dname="CY8C6248LQI-S2D02">
          <compile define="CY8C6248LQI_S2D02" />
        </device>
        <device Dname="CY8C6248LQI-S2D42">
          <compile define="CY8C6248LQI_S2D42" />
        </device>
      </subFamily>
      <!-- PSoC 62, CY8C62xA -->
      <subFamily DsubFamily="CY8C62xA">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_02.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_02.svd" />
        <debugvars configfile="Debug/CY8C6xxA.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 2;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40000CC8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40001000;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40000400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 2M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V2
          __var hsiomPrt7PortSel0Addr = 0x40300070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40300090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403103C4;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403104C4;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403103CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403104CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40201000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
          <sequence name="ResetSystem" Pname="Cortex-M0p">
            <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x40201120);
            vtBase = vtBase &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; ((vtBase &amp; 0xFFFF0000) != 0xFFFF0000);
          </block>
            <control if="appValid">
              <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
              <control if="resetAddress">
                <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);
                
                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);
                
                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;
                
                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);
                
                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
              </block>
                <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
                <block>
                __errorcontrol = 0;
              </block>
              </control>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00100000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00200000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA.FLM" start="0x10000000" size="0x00200000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_sect256KB.FLM" start="0x10000000" size="0x00200000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA.FLM" start="0x10000000" size="0x00200000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_sect256KB.FLM" start="0x10000000" size="0x00200000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C624AAZI-S2D14">
          <compile define="CY8C624AAZI_S2D14" />
        </device>
        <device Dname="CY8C624AAZI-S2D44">
          <compile define="CY8C624AAZI_S2D44" />
        </device>
        <device Dname="CY8C624ABZI-D44">
          <compile define="CY8C624ABZI_D44" />
        </device>
        <device Dname="CY8C624ABZI-S2D04">
          <compile define="CY8C624ABZI_S2D04" />
        </device>
        <device Dname="CY8C624ABZI-S2D14">
          <compile define="CY8C624ABZI_S2D14" />
        </device>
        <device Dname="CY8C624ABZI-S2D44">
          <compile define="CY8C624ABZI_S2D44" />
        </device>
        <device Dname="CY8C624ABZI-S2D44A0">
          <compile define="CY8C624ABZI_S2D44A0" />
        </device>
        <device Dname="CY8C624AFNI-S2D43">
          <compile define="CY8C624AFNI_S2D43" />
        </device>
        <device Dname="CY8C624ALQI-S2D02">
          <compile define="CY8C624ALQI_S2D02" />
        </device>
        <device Dname="CY8C624ALQI-S2D42">
          <compile define="CY8C624ALQI_S2D42" />
        </device>
      </subFamily>
    </family>
    <!-- PSoC 63 -->
    <family Dfamily="PSoC 63" Dvendor="Infineon:7">
      <book name="README.txt" title="Infineon PSoC 6 DFP user guide" />
      <book name="known_issues.txt" title="Infineon PSoC 6 DFP known issues" />
      <sequences>
        <sequence name="DAP_Handshake">
          <!-- DAP_Handshake: Execute initial handshake sequence depend on selected protocol -->
          <block>
            __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
            __var protType   = __protocol &amp; 0x0000FFFF;
            __var DPIDR = 0;
            __Result = 0;
          </block>
          <!-- JTAG Protocol -->
          <control if="protType == 1">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                DAP_SWJ_Sequence(16, 0xE73C);
              </block>
            </control>
            <block atomic="true">
              // JTAG "Soft" Reset
              DAP_JTAG_Sequence(6, 1, 0x00);                        // Test-Logic-Reset
              // Get IDCODE to make shure that JTAG-DP is available
              DAP_JTAG_Sequence(4, 0, 0x00);                        // 4*Run-Test/Idle
              DAP_JTAG_Sequence(2, 1, 0x00);                        // ~ Select-DR ~ Select-IR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-IR ~ Shift-IR
              DAP_JTAG_Sequence(8, 0, 0xFE);                        // Shift-IR (IDCODE BYPASS)
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-IR (IDCODE BYPASS) ~ Update-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
              DAP_JTAG_Sequence(1, 1, 0x00);                        // Select-DR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-DR ~ Shift-DR
              DPIDR = DAP_JTAG_Sequence(33, 0, 0x00000000);         // Shift 33-bits data
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-DR ~ Update-DR ~ ~ Select-DR ~ Select-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
            </block>
          </control>
          <!-- SWD Protocol -->
          <control if="protType == 2">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E)
                // Change if SWJ-DP uses deprecated switch code (0xEDB6)
                DAP_SWJ_Sequence(16, 0xE79E);
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <control if="!isSWJ">
              <block atomic="true">
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <block>
              DPIDR = ReadDP(0x0); // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
            </block>
          </control>
          <control if="(DPIDR &amp; 0xFFF00FFF) != 0x6BA00477">
            <block>
              __Result = -1; // DAP is unavailable
            </block>
          </control>
        </sequence>
        <sequence name="DAP_poll">
          <!-- DAP_poll: Poll the DAP until it becomes available -->
          <block>
            __Result = -1; // Assume DAP is not available yet
          </block>
          <control while="__Result != 0" timeout="600000">
            <block>
              sequence("DAP_Handshake"); // Poll DP until bootloader allows access to device (can be up to 600ms)
            </block>
          </control>
          <control if="__Result != 0">
            <block>
              Message(1, "The Debug Access Port is unavailable.");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortSetup">
          <!-- DebugPortSetup: Prepare the target debug port for connection -->
          <block>
            sequence("DAP_Handshake");
          </block>
          <control if="__Result != 0">
            <!-- In case DAP isn't avalable, execute a system-wide reset via dedicated debugger reset line. -->
            <block>
              __var nReset      = 0x80;
              __var canReadPins = 0;
              canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
            </block>
            <!-- Keep reset active for 50 ms -->
            <control while="1" timeout="50000" />
            <control if="canReadPins">
              <!-- Assert nRESET line and wait max. 1s for recovery -->
              <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
            </control>
            <control if="!canReadPins">
              <block>
                DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
              </block>
              <!-- Wait 100ms for recovery if nRESET not readable -->
              <control while="1" timeout="100000" />
            </control>
            <block>
              sequence("DAP_poll");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortStart">
          <!-- DebugPortStart: Connect to the target debug port and power it up -->
          <block info="Read DP CTRL/STAT">
            __var SW_DP_ABORT  = 0x0;
            __var DP_CTRL_STAT = 0x4;
            __var DP_SELECT    = 0x8;
            __var powered_down = 0;
            // Switch to DP Register Bank 0. Explicitly set APSEL to current AP selection
            WriteDP(DP_SELECT, __ap &lt;&lt; 24);
            // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
            powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
          </block>
          <control if="powered_down">
            <block info="Power Up System &amp; Debug">
              // Request Debug/System Power-Up
              // Ignore error here: even there is a polling in the next block, CMSIS-DAP transports reads DP.RDBUFF register
              // right after write to DP.CTRL_STAT. This will fail for some cases - for example if device is waking from DeepSleep.
              __errorcontrol = 1;
              WriteDP(DP_CTRL_STAT, 0x50000000);
              __errorcontrol = 0;
            </block>
            <!-- Wait for Power-Up Request to be acknowledged -->
            <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000" info="Wait for power acknowledged" />
            <!-- CDBGRSTREQ on PSoC6 behaves like Power-On Reset. Not desired when starting the Debug Port
            <block info="Debug Reset">
              __errorcontrol = 1;
              // Request Debug Reset
              WriteDP(DP_CTRL_STAT, 0x54000000);
              // CDBGRSTREQ is equivalent to Power-On Reset and fully reboots the device.
              // Depending on the user application the reboot can take up to 600ms.
              DAP_Delay(600000);
              __errorcontrol = 0;
            </block>
            -->
            <!-- Wait for Debug Reset to be acknowledged, don't issue error on timeout to deal with improperly connected Debug Reset -->
            <!-- <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA8000000) != 0xA8000000" timeout="300000" info="Wait for Debug Reset Acknowledge"/> -->
            <!-- JTAG Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 1">
              <block info="JTAG: Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                WriteDP(DP_CTRL_STAT, 0x50000F32);
              </block>
            </control>
            <!-- SWD Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 2">
              <block info="SWD: Init SWD &amp; Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                WriteDP(DP_CTRL_STAT, 0x50000F00);
                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                WriteDP(SW_DP_ABORT, 0x0000001E);
              </block>
            </control>
          </control>
          <block>
            Sequence("PrintDeviceInfo"); // Print device info
          </block>
        </sequence>
        <sequence name="ResetHardware">
          <!-- ResetHardware: HW Reset causes a reboot of the device which also resets debug.
               - Using this as a prereset is OK to potentially wake up the system from DeepSleep.
               - Using this in the middle of the debug session will break the connection unless recovery
                 from a connection loss is supported by the debug IDE.
          -->
          <block>
            __var nReset      = 0x80;
            __var canReadPins = 0;
            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
          </block>
          <!-- Keep reset active for 50 ms -->
          <control while="1" timeout="50000" />
          <control if="canReadPins">
            <!-- Assert nRESET line and wait max. 1s for recovery -->
            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
          </control>
          <control if="!canReadPins">
            <block>
              DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
            </block>
            <!-- Wait 100ms for recovery if nRESET not readable -->
            <control while="1" timeout="100000" />
          </control>
          <block>
            // Give the PSoC6 bootloader time to finish (can be up to 600ms)
            DAP_Delay(600000);
          </block>
        </sequence>
        <sequence name="PrintDeviceInfo">
          <!-- PrintDeviceInfo: Read and print device info -->
          <block>
            __var siId;
            __var siRev;
            __var siFamily;
            __var fbVerHi;
            __var sflashSvnVer;
            __var protection;
            __var v;
            Message(0, "****************************************************");
            // Get Si Id, Family and Rev.
            v = Read32(0x16000000);
            siId = (v &amp; 0xFFFF0000) &gt;&gt; 16;
            siRev = (v &amp; 0x0000FF00) &gt;&gt; 8;
            v = Read32(0x1600000C);
            siFamily = v &amp; 0x00000FFF;
            Message(0, "** Silicon: 0x%04X, Family: 0x%03X, Rev.: 0x%02X", siId, siFamily, siRev);
            // Get FlashBboot verison
            fbVerHi = Read32(0x16002004);
          </block>
          <control if="fbVerHi == 0">
            <block>
              Message(1, "Invalid FlashBoot: High version word of Flash Boot is zero");
            </block>
          </control>
          <control if="fbVerHi != 0">
            <block>
              __var fbVerLo = Read32(0x16002018);
              __var b0 = fbVerHi &gt;&gt; 28;
              __var b1 = (fbVerHi &gt;&gt; 24) &amp; 0x0F;
              __var b2 = (fbVerHi &gt;&gt; 16) &amp; 0xFF;
              __var b3 = fbVerHi &amp; 0x0000FFFF;
            </block>
            <control if="b0 &gt; 2">
              <block>
                Message(1, "Unsupported Flash Boot Version - Flash Boot Version [31:28] = 0x%X", b0);
              </block>
            </control>
            <control if="b0 &lt;= 2">
              <control if="b3 != 0x8001">
                <block>
                  Message(1, "Flash Boot is corrupted or non Flash Boot image programmed");
                </block>
              </control>
              <control if="b3 == 0x8001">
                <control if="b0 == 0">
                  <control if="b1 == 1">
                    <block>
                      Message(0, "** Flash Boot version: 1.%02u", b2);
                    </block>
                  </control>
                  <control if="b1 == 2">
                    <control if="b2 &lt; 20">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.0.%u", b2);
                      </block>
                    </control>
                    <control if="(b2 &gt;= 20) &amp;&amp; (b2 &lt; 29)">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.1.%u", b2);
                      </block>
                    </control>
                    <control if="b2 &gt;= 29">
                      <block>
                        Message(0, "** Flash Boot version: 1.20.1.%u", b2);
                      </block>
                    </control>
                  </control>
                </control>
                <control if="b0 == 1">
                  <block>
                    Message(0, "** Flash Boot version: 2.0.0.%u", b2);
                  </block>
                </control>
                <control if="b0 == 2">
                  <block>
                    __var patch = fbVerLo &gt;&gt; 24;
                    __var build = fbVerLo &amp; 0x0000FFFF;
                    Message(0, "** Flash Boot version: %u.%u.%u.%u", b1, b2, patch, build);
                  </block>
                </control>
              </control>
            </control>
          </control>
          <block>
            sflashSvnVer = Read32(0x16000028); // Get SFLASH version
          </block>
          <control if="(sflashSvnVer != 0) &amp;&amp; (sflashSvnVer != 0xFFFFFFFF)">
            <block>
              Message(0, "** SFlash version: %u", sflashSvnVer);
            </block>
          </control>
          <!-- Get life-cycle stage -->
          <control if="siFamily == 0x100">
            <block>
              protection = Read32(0x40210500); // PSoC 6-BLE2 family
            </block>
          </control>
          <control if="siFamily != 0x100">
            <block>
              protection = Read32(0x402020C4); // PSoC 6-2M family
            </block>
          </control>
          <!-- Decode life-cycle stage -->
          <control if="protection == 1">
            <block>
              Message(0, "** Chip Protection: VIRGIN");
            </block>
          </control>
          <control if="protection == 2">
            <block>
              Message(0, "** Chip Protection: NORMAL");
            </block>
          </control>
          <control if="protection == 3">
            <block>
              Message(0, "** Chip Protection: SECURE");
            </block>
          </control>
          <control if="protection == 4">
            <block>
              Message(0, "** Chip Protection: DEAD");
            </block>
          </control>
          <control if="(protection == 0) || (protection &gt; 4)">
            <block>
              Message(0, "** Chip Protection: UNKNOWN");
            </block>
          </control>
          <block>
            Message(0, "****************************************************");
          </block>
        </sequence>
      </sequences>
      <!-- PSoC 63, CY8C63x6 Single -->
      <subFamily DsubFamily="CY8C63x6">
        <processor Pname="Cortex-M4" Dcore="Cortex-M4" DcoreVersion="r0p1" Dfpu="1" Dmpu="1" Dendian="Little-endian" Dclock="150000000" />
        <description>PSoC 63 (Connectivity Line): Cortex-M4 MCU series with programmable digital and analog peripherals, advanced graphics, CapSense, crypto and secure boot security, with integrated high-speed wired and wireless connectivity.</description>
        <debug Pname="Cortex-M4" __ap="2" defaultResetSequence="ResetSystem" svd="SVD/psoc6_01.svd">
          <datapatch address="0xE008EFE0" value="0x000000A1" info="this is Cortex-M4 TPIU, not Cortex-M3 TPIU. Debuggers may determine by this that TPIU supports Half-Frame Syncs." />
        </debug>
        <debugvars configfile="Debug/CY8C6xx7.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 1;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40010CD8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40010800;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40010400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 1M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000000FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000008;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V1
          __var hsiomPrt7PortSel0Addr = 0x40310070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40310090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403203A8;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403204A8;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403203B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403204B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="DebugCoreStart" Pname="Cortex-M4">
            <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
            <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
            <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
              <block>
              Sequence("SetupTraceClock");
            </block>
            </control>
          </sequence>
          <!-- Configure pins trace pins if Parallel Trace Port enabled -->
          <sequence name="TraceStart" Pname="Cortex-M4">
            <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
              <block>
              __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
            </block>
              <control if="__TPIU_pinlocation == 1" info="CY8CKIT-062-WIFI-BT Like">
                <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
                <control if="tpWidth &gt;= 1">
                  <block>
                  sequence("SetupTracePin_P7_6");
                </block>
                </control>
                <control if="tpWidth &gt;= 2">
                  <block>
                  sequence("SetupTracePin_P7_5");
                  sequence("SetupTracePin_P7_4");
                </block>
                </control>
              </control>
              <control if="__TPIU_pinlocation == 2" info="CY8CKIT-062S2-43012 Like">
                <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
                <control if="tpWidth &gt;= 1">
                  <block>
                  sequence("SetupTracePin_P9_2");
                </block>
                </control>
                <control if="tpWidth &gt;= 2">
                  <block>
                  sequence("SetupTracePin_P9_1");
                  sequence("SetupTracePin_P9_0");
                </block>
                </control>
              </control>
            </control>
          </sequence>
          <sequence name="SetupTraceClock" Pname="Cortex-M4">
            <block>
            __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;    // PERI_CLOCK_CTL.DIV_SEL
            __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;       // ENABLE field in PERI_DIV_CMD
            __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;      // DISABLE field in PERI_DIV_CMD
            // Peripheral clock divider index to use for trace clock
            __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
            __var ClockDivVal = 0 &amp; PERI_DIV_PA_SEL_MASK;  // Peripheral clock divider value for trace clock
                                                               // Actual divider is (1+ClockDivVal)
            __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
            __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
          </block>
            <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
              <block>
              Message(0, "Setup TPIU clock");
              // DISABLE 8.0 DIV in PERI_DIV_CMD:
              __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              // Use selected divider (8.0) for cpuss.clock_trace_in
              Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
              // Set 8.0 DIV = ClockDivVal
              Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
              // ENABLE 8.0 DIV
              ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_0 as TRACECLK -->
          <sequence name="SetupTracePin_P7_0" Pname="Cortex-M4">
            <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1A;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P7_0)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACECLK to P7_0");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_4 as TRACEDATA[3] -->
          <sequence name="SetupTracePin_P7_4" Pname="Cortex-M4">
            <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[3] to P7_4");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_5 as TRACEDATA[2] -->
          <sequence name="SetupTracePin_P7_5" Pname="Cortex-M4">
            <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[2] to P7_5");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_6 as TRACEDATA[1] -->
          <sequence name="SetupTracePin_P7_6" Pname="Cortex-M4">
            <block>
            __var pin = 6;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[1] to P7_6");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_0 as TRACEDATA[3] -->
          <sequence name="SetupTracePin_P9_0" Pname="Cortex-M4">
            <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[3] to P9_0");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_1 as TRACEDATA[2] -->
          <sequence name="SetupTracePin_P9_1" Pname="Cortex-M4">
            <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[2] to P9_1");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_2 as TRACEDATA[1] -->
          <sequence name="SetupTracePin_P9_2" Pname="Cortex-M4">
            <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[1] to P9_2");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_3 as TRACEDATA[0]  -->
          <sequence name="SetupTracePin_P9_3" Pname="Cortex-M4">
            <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[0] to P9_3");
            </block>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00020000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00080000" default="1" startup="1" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6316BZI-BLF03">
          <compile define="CY8C6316BZI_BLF03" />
        </device>
        <device Dname="CY8C6316BZI-BLF04">
          <compile define="CY8C6316BZI_BLF04" />
        </device>
        <device Dname="CY8C6316BZI-BLF53">
          <compile define="CY8C6316BZI_BLF53" />
        </device>
        <device Dname="CY8C6316BZI-BLF54">
          <compile define="CY8C6316BZI_BLF54" />
        </device>
        <device Dname="CY8C6336BZI-BLF03">
          <compile define="CY8C6336BZI_BLF03" />
        </device>
        <device Dname="CY8C6336BZI-BLF04">
          <compile define="CY8C6336BZI_BLF04" />
        </device>
        <device Dname="CY8C6336LQI-BLF02">
          <compile define="CY8C6336LQI_BLF02" />
        </device>
        <device Dname="CY8C6336LQI-BLF42">
          <compile define="CY8C6336LQI_BLF42" />
        </device>
      </subFamily>
      <!-- PSoC 63, CY8C63x6 Dual -->
      <subFamily DsubFamily="CY8C63x6 Dual">
        <processor Pname="Cortex-M0p" Dcore="Cortex-M0+" DcoreVersion="r0p1" Dfpu="NO_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="100000000" />
        <processor Pname="Cortex-M4" Dcore="Cortex-M4" DcoreVersion="r0p1" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="150000000" />
        <description>PSoC 63 (Connectivity Line): Dual-core Cortex-M4/M0+ MCU series with programmable digital and analog peripherals, advanced graphics, CapSense, crypto and secure boot security, with integrated high-speed wired and wireless connectivity.</description>
        <debug Pname="Cortex-M0p" __ap="1" defaultResetSequence="ResetProcessor" svd="SVD/psoc6_01.svd" />
        <debug Pname="Cortex-M4" __ap="2" defaultResetSequence="ResetSystem" svd="SVD/psoc6_01.svd">
          <datapatch address="0xE008EFE0" value="0x000000A1" info="this is Cortex-M4 TPIU, not Cortex-M3 TPIU. Debuggers may determine by this that TPIU supports Half-Frame Syncs." />
        </debug>
        <debugvars configfile="Debug/CY8C6xx7.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 1;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40010CD8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40010800;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40010400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 1M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000000FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000008;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V1
          __var hsiomPrt7PortSel0Addr = 0x40310070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40310090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403203A8;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403204A8;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403203B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403204B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40210000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
          <sequence name="ResetSystem" Pname="Cortex-M0p">
            <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x402102B0);
            vtBase = vtBase &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; ((vtBase &amp; 0xFFFF0000) != 0xFFFF0000);
          </block>
            <control if="appValid">
              <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
              <control if="resetAddress">
                <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);
                
                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);
                
                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;
                
                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);
                
                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
              </block>
                <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
                <block>
                __errorcontrol = 0;
              </block>
              </control>
            </control>
          </sequence>
          <sequence name="DebugCoreStart" Pname="Cortex-M4">
            <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
            <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
            <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
              <block>
              Sequence("SetupTraceClock");
            </block>
            </control>
          </sequence>
          <!-- Configure pins trace pins if Parallel Trace Port enabled -->
          <sequence name="TraceStart" Pname="Cortex-M4">
            <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
              <block>
              __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
            </block>
              <control if="__TPIU_pinlocation == 1" info="CY8CKIT-062-WIFI-BT Like">
                <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
                <control if="tpWidth &gt;= 1">
                  <block>
                  sequence("SetupTracePin_P7_6");
                </block>
                </control>
                <control if="tpWidth &gt;= 2">
                  <block>
                  sequence("SetupTracePin_P7_5");
                  sequence("SetupTracePin_P7_4");
                </block>
                </control>
              </control>
              <control if="__TPIU_pinlocation == 2" info="CY8CKIT-062S2-43012 Like">
                <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
                <control if="tpWidth &gt;= 1">
                  <block>
                  sequence("SetupTracePin_P9_2");
                </block>
                </control>
                <control if="tpWidth &gt;= 2">
                  <block>
                  sequence("SetupTracePin_P9_1");
                  sequence("SetupTracePin_P9_0");
                </block>
                </control>
              </control>
            </control>
          </sequence>
          <sequence name="SetupTraceClock" Pname="Cortex-M4">
            <block>
            __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;    // PERI_CLOCK_CTL.DIV_SEL
            __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;       // ENABLE field in PERI_DIV_CMD
            __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;      // DISABLE field in PERI_DIV_CMD
            // Peripheral clock divider index to use for trace clock
            __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
            __var ClockDivVal = 0 &amp; PERI_DIV_PA_SEL_MASK;  // Peripheral clock divider value for trace clock
                                                               // Actual divider is (1+ClockDivVal)
            __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
            __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
          </block>
            <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
              <block>
              Message(0, "Setup TPIU clock");
              // DISABLE 8.0 DIV in PERI_DIV_CMD:
              __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              // Use selected divider (8.0) for cpuss.clock_trace_in
              Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
              // Set 8.0 DIV = ClockDivVal
              Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
              // ENABLE 8.0 DIV
              ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_0 as TRACECLK -->
          <sequence name="SetupTracePin_P7_0" Pname="Cortex-M4">
            <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1A;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P7_0)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACECLK to P7_0");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_4 as TRACEDATA[3] -->
          <sequence name="SetupTracePin_P7_4" Pname="Cortex-M4">
            <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[3] to P7_4");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_5 as TRACEDATA[2] -->
          <sequence name="SetupTracePin_P7_5" Pname="Cortex-M4">
            <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[2] to P7_5");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_6 as TRACEDATA[1] -->
          <sequence name="SetupTracePin_P7_6" Pname="Cortex-M4">
            <block>
            __var pin = 6;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[1] to P7_6");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_0 as TRACEDATA[3] -->
          <sequence name="SetupTracePin_P9_0" Pname="Cortex-M4">
            <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[3] to P9_0");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_1 as TRACEDATA[2] -->
          <sequence name="SetupTracePin_P9_1" Pname="Cortex-M4">
            <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[2] to P9_1");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_2 as TRACEDATA[1] -->
          <sequence name="SetupTracePin_P9_2" Pname="Cortex-M4">
            <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[1] to P9_2");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_3 as TRACEDATA[0]  -->
          <sequence name="SetupTracePin_P9_3" Pname="Cortex-M4">
            <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[0] to P9_3");
            </block>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00020000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00080000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx6.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx6_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx6_sect256KB.FLM" start="0x10000000" size="0x00080000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6336BZI-BLD13">
          <compile define="CY8C6336BZI_BLD13" />
        </device>
        <device Dname="CY8C6336BZI-BLD14">
          <compile define="CY8C6336BZI_BLD14" />
        </device>
      </subFamily>
      <!-- PSoC 63, CY8C63x7 Single -->
      <subFamily DsubFamily="CY8C63x7">
        <processor Pname="Cortex-M4" Dcore="Cortex-M4" DcoreVersion="r0p1" Dfpu="1" Dmpu="1" Dendian="Little-endian" Dclock="150000000" />
        <description>PSoC 63 (Connectivity Line): Cortex-M4 MCU series with programmable digital and analog peripherals, advanced graphics, CapSense, crypto and secure boot security, with integrated high-speed wired and wireless connectivity.</description>
        <debug Pname="Cortex-M4" __ap="2" defaultResetSequence="ResetSystem" svd="SVD/psoc6_01.svd">
          <datapatch address="0xE008EFE0" value="0x000000A1" info="this is Cortex-M4 TPIU, not Cortex-M3 TPIU. Debuggers may determine by this that TPIU supports Half-Frame Syncs." />
        </debug>
        <debugvars configfile="Debug/CY8C6xx7.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 1;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40010CD8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40010800;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40010400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 1M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000000FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000008;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V1
          __var hsiomPrt7PortSel0Addr = 0x40310070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40310090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403203A8;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403204A8;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403203B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403204B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="DebugCoreStart" Pname="Cortex-M4">
            <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
            <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
            <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
              <block>
              Sequence("SetupTraceClock");
            </block>
            </control>
          </sequence>
          <!-- Configure pins trace pins if Parallel Trace Port enabled -->
          <sequence name="TraceStart" Pname="Cortex-M4">
            <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
              <block>
              __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
            </block>
              <control if="__TPIU_pinlocation == 1" info="CY8CKIT-062-WIFI-BT Like">
                <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
                <control if="tpWidth &gt;= 1">
                  <block>
                  sequence("SetupTracePin_P7_6");
                </block>
                </control>
                <control if="tpWidth &gt;= 2">
                  <block>
                  sequence("SetupTracePin_P7_5");
                  sequence("SetupTracePin_P7_4");
                </block>
                </control>
              </control>
              <control if="__TPIU_pinlocation == 2" info="CY8CKIT-062S2-43012 Like">
                <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
                <control if="tpWidth &gt;= 1">
                  <block>
                  sequence("SetupTracePin_P9_2");
                </block>
                </control>
                <control if="tpWidth &gt;= 2">
                  <block>
                  sequence("SetupTracePin_P9_1");
                  sequence("SetupTracePin_P9_0");
                </block>
                </control>
              </control>
            </control>
          </sequence>
          <sequence name="SetupTraceClock" Pname="Cortex-M4">
            <block>
            __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;    // PERI_CLOCK_CTL.DIV_SEL
            __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;       // ENABLE field in PERI_DIV_CMD
            __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;      // DISABLE field in PERI_DIV_CMD
            // Peripheral clock divider index to use for trace clock
            __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
            __var ClockDivVal = 0 &amp; PERI_DIV_PA_SEL_MASK;  // Peripheral clock divider value for trace clock
                                                               // Actual divider is (1+ClockDivVal)
            __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
            __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
          </block>
            <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
              <block>
              Message(0, "Setup TPIU clock");
              // DISABLE 8.0 DIV in PERI_DIV_CMD:
              __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              // Use selected divider (8.0) for cpuss.clock_trace_in
              Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
              // Set 8.0 DIV = ClockDivVal
              Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
              // ENABLE 8.0 DIV
              ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_0 as TRACECLK -->
          <sequence name="SetupTracePin_P7_0" Pname="Cortex-M4">
            <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1A;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P7_0)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACECLK to P7_0");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_4 as TRACEDATA[3] -->
          <sequence name="SetupTracePin_P7_4" Pname="Cortex-M4">
            <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[3] to P7_4");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_5 as TRACEDATA[2] -->
          <sequence name="SetupTracePin_P7_5" Pname="Cortex-M4">
            <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[2] to P7_5");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_6 as TRACEDATA[1] -->
          <sequence name="SetupTracePin_P7_6" Pname="Cortex-M4">
            <block>
            __var pin = 6;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[1] to P7_6");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_0 as TRACEDATA[3] -->
          <sequence name="SetupTracePin_P9_0" Pname="Cortex-M4">
            <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[3] to P9_0");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_1 as TRACEDATA[2] -->
          <sequence name="SetupTracePin_P9_1" Pname="Cortex-M4">
            <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[2] to P9_1");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_2 as TRACEDATA[1] -->
          <sequence name="SetupTracePin_P9_2" Pname="Cortex-M4">
            <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[1] to P9_2");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_3 as TRACEDATA[0]  -->
          <sequence name="SetupTracePin_P9_3" Pname="Cortex-M4">
            <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[0] to P9_3");
            </block>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00048000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00100000" default="1" startup="1" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx7.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx7_sect256KB.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6337BZI-BLF13">
          <compile define="CY8C6337BZI_BLF13" />
        </device>
      </subFamily>
      <!-- PSoC 63, CY8C63x7 Dual -->
      <subFamily DsubFamily="CY8C63x7 Dual">
        <processor Pname="Cortex-M0p" Dcore="Cortex-M0+" DcoreVersion="r0p1" Dfpu="NO_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="100000000" />
        <processor Pname="Cortex-M4" Dcore="Cortex-M4" DcoreVersion="r0p1" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="150000000" />
        <description>PSoC 63 (Connectivity Line): Dual-core Cortex-M4/M0+ MCU series with programmable digital and analog peripherals, advanced graphics, CapSense, crypto and secure boot security, with integrated high-speed wired and wireless connectivity.</description>
        <debug Pname="Cortex-M0p" __ap="1" defaultResetSequence="ResetProcessor" svd="SVD/psoc6_01.svd" />
        <debug Pname="Cortex-M4" __ap="2" defaultResetSequence="ResetSystem" svd="SVD/psoc6_01.svd">
          <datapatch address="0xE008EFE0" value="0x000000A1" info="this is Cortex-M4 TPIU, not Cortex-M3 TPIU. Debuggers may determine by this that TPIU supports Half-Frame Syncs." />
        </debug>
        <debugvars configfile="Debug/CY8C6xx7.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 1;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40010CD8;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40010800;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40010400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x07;               // 1M devices have 8 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000000FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000008;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V1
          __var hsiomPrt7PortSel0Addr = 0x40310070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40310090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403203A8;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403204A8;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403203B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403204B0;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40210000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
          <sequence name="ResetSystem" Pname="Cortex-M0p">
            <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x402102B0);
            vtBase = vtBase &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; ((vtBase &amp; 0xFFFF0000) != 0xFFFF0000);
          </block>
            <control if="appValid">
              <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
              <control if="resetAddress">
                <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);
                
                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);
                
                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;
                
                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);
                
                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
              </block>
                <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
                <block>
                __errorcontrol = 0;
              </block>
              </control>
            </control>
          </sequence>
          <sequence name="DebugCoreStart" Pname="Cortex-M4">
            <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
            <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
            <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
              <block>
              Sequence("SetupTraceClock");
            </block>
            </control>
          </sequence>
          <!-- Configure pins trace pins if Parallel Trace Port enabled -->
          <sequence name="TraceStart" Pname="Cortex-M4">
            <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
              <block>
              __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
            </block>
              <control if="__TPIU_pinlocation == 1" info="CY8CKIT-062-WIFI-BT Like">
                <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
                <control if="tpWidth &gt;= 1">
                  <block>
                  sequence("SetupTracePin_P7_6");
                </block>
                </control>
                <control if="tpWidth &gt;= 2">
                  <block>
                  sequence("SetupTracePin_P7_5");
                  sequence("SetupTracePin_P7_4");
                </block>
                </control>
              </control>
              <control if="__TPIU_pinlocation == 2" info="CY8CKIT-062S2-43012 Like">
                <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
                <control if="tpWidth &gt;= 1">
                  <block>
                  sequence("SetupTracePin_P9_2");
                </block>
                </control>
                <control if="tpWidth &gt;= 2">
                  <block>
                  sequence("SetupTracePin_P9_1");
                  sequence("SetupTracePin_P9_0");
                </block>
                </control>
              </control>
            </control>
          </sequence>
          <sequence name="SetupTraceClock" Pname="Cortex-M4">
            <block>
            __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;    // PERI_CLOCK_CTL.DIV_SEL
            __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;       // ENABLE field in PERI_DIV_CMD
            __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;      // DISABLE field in PERI_DIV_CMD
            // Peripheral clock divider index to use for trace clock
            __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
            __var ClockDivVal = 0 &amp; PERI_DIV_PA_SEL_MASK;  // Peripheral clock divider value for trace clock
                                                               // Actual divider is (1+ClockDivVal)
            __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
            __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
          </block>
            <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
              <block>
              Message(0, "Setup TPIU clock");
              // DISABLE 8.0 DIV in PERI_DIV_CMD:
              __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              // Use selected divider (8.0) for cpuss.clock_trace_in
              Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
              // Set 8.0 DIV = ClockDivVal
              Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
              // ENABLE 8.0 DIV
              ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_0 as TRACECLK -->
          <sequence name="SetupTracePin_P7_0" Pname="Cortex-M4">
            <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1A;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P7_0)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACECLK to P7_0");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_4 as TRACEDATA[3] -->
          <sequence name="SetupTracePin_P7_4" Pname="Cortex-M4">
            <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[3] to P7_4");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_5 as TRACEDATA[2] -->
          <sequence name="SetupTracePin_P7_5" Pname="Cortex-M4">
            <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[2] to P7_5");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P7_6 as TRACEDATA[1] -->
          <sequence name="SetupTracePin_P7_6" Pname="Cortex-M4">
            <block>
            __var pin = 6;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[1] to P7_6");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_0 as TRACEDATA[3] -->
          <sequence name="SetupTracePin_P9_0" Pname="Cortex-M4">
            <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[3] to P9_0");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_1 as TRACEDATA[2] -->
          <sequence name="SetupTracePin_P9_1" Pname="Cortex-M4">
            <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[2] to P9_1");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_2 as TRACEDATA[1] -->
          <sequence name="SetupTracePin_P9_2" Pname="Cortex-M4">
            <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[1] to P9_2");
            </block>
            </control>
          </sequence>
          <!-- Setup Trace Pin P9_3 as TRACEDATA[0]  -->
          <sequence name="SetupTracePin_P9_3" Pname="Cortex-M4">
            <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
            <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
            <control if="pin &lt; 4">
              <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <control if="pin &gt; 3">
              <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
            </control>
            <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
            <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
            <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
            <control if="reg0 |= reg1">
              <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
            </control>
            <control if="confChanged |= 0">
              <block>
              Message(0, "Set TRACEDATA[0] to P9_3");
            </block>
            </control>
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00048000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00100000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx7.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx7_sect256KB.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx7.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx7_sect256KB.FLM" start="0x10000000" size="0x00100000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08026400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C6347BZI-BLD33">
          <compile define="CY8C6347BZI_BLD33" />
        </device>
        <device Dname="CY8C6347BZI-BLD34">
          <compile define="CY8C6347BZI_BLD34" />
        </device>
        <device Dname="CY8C6347BZI-BLD43">
          <compile define="CY8C6347BZI_BLD43" />
        </device>
        <device Dname="CY8C6347BZI-BLD44">
          <compile define="CY8C6347BZI_BLD44" />
        </device>
        <device Dname="CY8C6347BZI-BLD53">
          <compile define="CY8C6347BZI_BLD53" />
        </device>
        <device Dname="CY8C6347BZI-BLD54">
          <compile define="CY8C6347BZI_BLD54" />
        </device>
        <device Dname="CY8C6347FMI-BLD13">
          <compile define="CY8C6347FMI_BLD13" />
        </device>
        <device Dname="CY8C6347FMI-BLD33">
          <compile define="CY8C6347FMI_BLD33" />
        </device>
        <device Dname="CY8C6347FMI-BLD43">
          <compile define="CY8C6347FMI_BLD43" />
        </device>
        <device Dname="CY8C6347FMI-BLD53">
          <compile define="CY8C6347FMI_BLD53" />
        </device>
        <device Dname="CY8C6347FMI-BUD13">
          <compile define="CY8C6347FMI_BUD13" />
        </device>
        <device Dname="CY8C6347FMI-BUD33">
          <compile define="CY8C6347FMI_BUD33" />
        </device>
        <device Dname="CY8C6347FMI-BUD43">
          <compile define="CY8C6347FMI_BUD43" />
        </device>
        <device Dname="CY8C6347FMI-BUD53">
          <compile define="CY8C6347FMI_BUD53" />
        </device>
        <device Dname="CY8C6347LQI-BLD52">
          <compile define="CY8C6347LQI_BLD52" />
        </device>
        <device Dname="CYBLE-416045-02">
          <compile define="CYBLE_416045_02" />
        </device>
      </subFamily>
    </family>
    <!-- PSoC 64 -->
    <family Dfamily="PSoC 64" Dvendor="Infineon:7">
      <processor Pname="Cortex-M0p" Dcore="Cortex-M0+" DcoreVersion="r0p1" Dfpu="NO_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="100000000" />
      <processor Pname="Cortex-M4" Dcore="Cortex-M4" DcoreVersion="r0p1" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="150000000" />
      <description>PSoC 64 (Security Line): Dual-core Cortex-M4/M0+ MCU series with programmable digital and analog peripherals, advanced graphics, CapSense, crypto and secure boot security.</description>
      <debug Pname="Cortex-M0p" __ap="1" defaultResetSequence="ResetProcessor" />
      <debug Pname="Cortex-M4" __ap="2" defaultResetSequence="ResetSystem">
        <datapatch address="0xE008EFE0" value="0x000000A1" info="this is Cortex-M4 TPIU, not Cortex-M3 TPIU. Debuggers may determine by this that TPIU supports Half-Frame Syncs." />
      </debug>
      <book name="README.txt" title="Infineon PSoC 6 DFP user guide" />
      <book name="known_issues.txt" title="Infineon PSoC 6 DFP known issues" />
      <sequences>
        <sequence name="DAP_Handshake">
          <!-- DAP_Handshake: Execute initial handshake sequence depend on selected protocol -->
          <block>
            __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
            __var protType   = __protocol &amp; 0x0000FFFF;
            __var DPIDR = 0;
            __Result = 0;
          </block>
          <!-- JTAG Protocol -->
          <control if="protType == 1">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                DAP_SWJ_Sequence(16, 0xE73C);
              </block>
            </control>
            <block atomic="true">
              // JTAG "Soft" Reset
              DAP_JTAG_Sequence(6, 1, 0x00);                        // Test-Logic-Reset
              // Get IDCODE to make shure that JTAG-DP is available
              DAP_JTAG_Sequence(4, 0, 0x00);                        // 4*Run-Test/Idle
              DAP_JTAG_Sequence(2, 1, 0x00);                        // ~ Select-DR ~ Select-IR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-IR ~ Shift-IR
              DAP_JTAG_Sequence(8, 0, 0xFE);                        // Shift-IR (IDCODE BYPASS)
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-IR (IDCODE BYPASS) ~ Update-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
              DAP_JTAG_Sequence(1, 1, 0x00);                        // Select-DR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-DR ~ Shift-DR
              DPIDR = DAP_JTAG_Sequence(33, 0, 0x00000000);         // Shift 33-bits data
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-DR ~ Update-DR ~ ~ Select-DR ~ Select-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
            </block>
          </control>
          <!-- SWD Protocol -->
          <control if="protType == 2">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E)
                // Change if SWJ-DP uses deprecated switch code (0xEDB6)
                DAP_SWJ_Sequence(16, 0xE79E);
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <control if="!isSWJ">
              <block atomic="true">
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <block>
              DPIDR = ReadDP(0x0); // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
            </block>
          </control>
          <control if="(DPIDR &amp; 0xFFF00FFF) != 0x6BA00477">
            <block>
              __Result = -1; // DAP is unavailable
            </block>
          </control>
        </sequence>
        <sequence name="DAP_poll">
          <!-- DAP_poll: Poll the DAP until it becomes available -->
          <block>
            __Result = -1; // Assume DAP is not available yet
          </block>
          <control while="__Result != 0" timeout="600000">
            <block>
              sequence("DAP_Handshake"); // Poll DP until bootloader allows access to device (can be up to 600ms)
            </block>
          </control>
          <control if="__Result != 0">
            <block>
              Message(1, "The Debug Access Port is unavailable.");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortSetup">
          <!-- DebugPortSetup: Prepare the target debug port for connection -->
          <block>
            sequence("DAP_Handshake");
          </block>
          <control if="__Result != 0">
            <!-- In case DAP isn't avalable, execute a system-wide reset via dedicated debugger reset line. -->
            <block>
              __var nReset      = 0x80;
              __var canReadPins = 0;
              canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
            </block>
            <!-- Keep reset active for 50 ms -->
            <control while="1" timeout="50000" />
            <control if="canReadPins">
              <!-- Assert nRESET line and wait max. 1s for recovery -->
              <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
            </control>
            <control if="!canReadPins">
              <block>
                DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
              </block>
              <!-- Wait 100ms for recovery if nRESET not readable -->
              <control while="1" timeout="100000" />
            </control>
            <block>
              sequence("DAP_poll");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortStart">
          <!-- DebugPortStart: Connect to the target debug port and power it up -->
          <block info="Read DP CTRL/STAT">
            __var SW_DP_ABORT  = 0x0;
            __var DP_CTRL_STAT = 0x4;
            __var DP_SELECT    = 0x8;
            __var powered_down = 0;
            // Switch to DP Register Bank 0. Explicitly set APSEL to current AP selection
            WriteDP(DP_SELECT, __ap &lt;&lt; 24);
            // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
            powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
          </block>
          <control if="powered_down">
            <block info="Power Up System &amp; Debug">
              // Request Debug/System Power-Up
              // Ignore error here: even there is a polling in the next block, CMSIS-DAP transports reads DP.RDBUFF register
              // right after write to DP.CTRL_STAT. This will fail for some cases - for example if device is waking from DeepSleep.
              __errorcontrol = 1;
              WriteDP(DP_CTRL_STAT, 0x50000000);
              __errorcontrol = 0;
            </block>
            <!-- Wait for Power-Up Request to be acknowledged -->
            <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000" info="Wait for power acknowledged" />
            <!-- CDBGRSTREQ on PSoC6 behaves like Power-On Reset. Not desired when starting the Debug Port
            <block info="Debug Reset">
              __errorcontrol = 1;
              // Request Debug Reset
              WriteDP(DP_CTRL_STAT, 0x54000000);
              // CDBGRSTREQ is equivalent to Power-On Reset and fully reboots the device.
              // Depending on the user application the reboot can take up to 600ms.
              DAP_Delay(600000);
              __errorcontrol = 0;
            </block>
            -->
            <!-- Wait for Debug Reset to be acknowledged, don't issue error on timeout to deal with improperly connected Debug Reset -->
            <!-- <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA8000000) != 0xA8000000" timeout="300000" info="Wait for Debug Reset Acknowledge"/> -->
            <!-- JTAG Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 1">
              <block info="JTAG: Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                WriteDP(DP_CTRL_STAT, 0x50000F32);
              </block>
            </control>
            <!-- SWD Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 2">
              <block info="SWD: Init SWD &amp; Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                WriteDP(DP_CTRL_STAT, 0x50000F00);
                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                WriteDP(SW_DP_ABORT, 0x0000001E);
              </block>
            </control>
          </control>
          <block>
            Sequence("PrintDeviceInfo"); // Print device info
          </block>
        </sequence>
        <sequence name="ResetHardware">
          <!-- ResetHardware: HW Reset causes a reboot of the device which also resets debug.
               - Using this as a prereset is OK to potentially wake up the system from DeepSleep.
               - Using this in the middle of the debug session will break the connection unless recovery
                 from a connection loss is supported by the debug IDE.
          -->
          <block>
            __var nReset      = 0x80;
            __var canReadPins = 0;
            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
          </block>
          <!-- Keep reset active for 50 ms -->
          <control while="1" timeout="50000" />
          <control if="canReadPins">
            <!-- Assert nRESET line and wait max. 1s for recovery -->
            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
          </control>
          <control if="!canReadPins">
            <block>
              DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
            </block>
            <!-- Wait 100ms for recovery if nRESET not readable -->
            <control while="1" timeout="100000" />
          </control>
          <block>
            // Give the PSoC6 bootloader time to finish (can be up to 600ms)
            DAP_Delay(600000);
          </block>
        </sequence>
        <sequence name="PrintDeviceInfo">
          <!-- PrintDeviceInfo: Read and print device info -->
          <block>
            __var siId;
            __var siRev;
            __var siFamily;
            __var fbVerHi;
            __var sflashSvnVer;
            __var protection;
            __var v;
            Message(0, "****************************************************");
            // Get Si Id, Family and Rev.
            v = Read32(0x16000000);
            siId = (v &amp; 0xFFFF0000) &gt;&gt; 16;
            siRev = (v &amp; 0x0000FF00) &gt;&gt; 8;
            v = Read32(0x1600000C);
            siFamily = v &amp; 0x00000FFF;
            Message(0, "** Silicon: 0x%04X, Family: 0x%03X, Rev.: 0x%02X", siId, siFamily, siRev);
            // Get FlashBboot verison
            fbVerHi = Read32(0x16002004);
          </block>
          <control if="fbVerHi == 0">
            <block>
              Message(1, "Invalid FlashBoot: High version word of Flash Boot is zero");
            </block>
          </control>
          <control if="fbVerHi != 0">
            <block>
              __var fbVerLo = Read32(0x16002018);
              __var b0 = fbVerHi &gt;&gt; 28;
              __var b1 = (fbVerHi &gt;&gt; 24) &amp; 0x0F;
              __var b2 = (fbVerHi &gt;&gt; 16) &amp; 0xFF;
              __var b3 = fbVerHi &amp; 0x0000FFFF;
            </block>
            <control if="b0 &gt; 2">
              <block>
                Message(1, "Unsupported Flash Boot Version - Flash Boot Version [31:28] = 0x%X", b0);
              </block>
            </control>
            <control if="b0 &lt;= 2">
              <control if="b3 != 0x8001">
                <block>
                  Message(1, "Flash Boot is corrupted or non Flash Boot image programmed");
                </block>
              </control>
              <control if="b3 == 0x8001">
                <control if="b0 == 0">
                  <control if="b1 == 1">
                    <block>
                      Message(0, "** Flash Boot version: 1.%02u", b2);
                    </block>
                  </control>
                  <control if="b1 == 2">
                    <control if="b2 &lt; 20">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.0.%u", b2);
                      </block>
                    </control>
                    <control if="(b2 &gt;= 20) &amp;&amp; (b2 &lt; 29)">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.1.%u", b2);
                      </block>
                    </control>
                    <control if="b2 &gt;= 29">
                      <block>
                        Message(0, "** Flash Boot version: 1.20.1.%u", b2);
                      </block>
                    </control>
                  </control>
                </control>
                <control if="b0 == 1">
                  <block>
                    Message(0, "** Flash Boot version: 2.0.0.%u", b2);
                  </block>
                </control>
                <control if="b0 == 2">
                  <block>
                    __var patch = fbVerLo &gt;&gt; 24;
                    __var build = fbVerLo &amp; 0x0000FFFF;
                    Message(0, "** Flash Boot version: %u.%u.%u.%u", b1, b2, patch, build);
                  </block>
                </control>
              </control>
            </control>
          </control>
          <block>
            sflashSvnVer = Read32(0x16000028); // Get SFLASH version
          </block>
          <control if="(sflashSvnVer != 0) &amp;&amp; (sflashSvnVer != 0xFFFFFFFF)">
            <block>
              Message(0, "** SFlash version: %u", sflashSvnVer);
            </block>
          </control>
          <!-- Get life-cycle stage -->
          <control if="siFamily == 0x100">
            <block>
              protection = Read32(0x40210500); // PSoC 6-BLE2 family
            </block>
          </control>
          <control if="siFamily != 0x100">
            <block>
              protection = Read32(0x402020C4); // PSoC 6-2M family
            </block>
          </control>
          <!-- Decode life-cycle stage -->
          <control if="protection == 1">
            <block>
              Message(0, "** Chip Protection: VIRGIN");
            </block>
          </control>
          <control if="protection == 2">
            <block>
              Message(0, "** Chip Protection: NORMAL");
            </block>
          </control>
          <control if="protection == 3">
            <block>
              Message(0, "** Chip Protection: SECURE");
            </block>
          </control>
          <control if="protection == 4">
            <block>
              Message(0, "** Chip Protection: DEAD");
            </block>
          </control>
          <control if="(protection == 0) || (protection &gt; 4)">
            <block>
              Message(0, "** Chip Protection: UNKNOWN");
            </block>
          </control>
          <block>
            Message(0, "****************************************************");
          </block>
        </sequence>
      </sequences>
      <!-- PSoC 64, CYB06xx5 -->
      <subFamily DsubFamily="CYB06xx5">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_03.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_03.svd" />
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40201000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00040000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00060000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CYxx64x5.FLM" start="0x10000000" size="0x00060000" RAMstart="0x08020000" RAMsize="0xC000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SMIF_S25Hx512T.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08020000" RAMsize="0xC000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CYxx64x5.FLM" start="0x10000000" size="0x00060000" RAMstart="0x08001800" RAMsize="0x1E800" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF_S25Hx512T.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08001800" RAMsize="0x1E800" default="0" style="Keil" />
        <device Dname="CYB06445LQI-S3D42">
          <compile define="CYB06445LQI_S3D42" />
        </device>
      </subFamily>
      <!-- PSoC 64, CYB06xx7 -->
      <subFamily DsubFamily="CYB06xx7">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_01.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_01.svd" />
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40210000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00048000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x000D0000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CYxx64xx.FLM" start="0x10000000" size="0x000D0000" RAMstart="0x08020000" RAMsize="0xC000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08020000" RAMsize="0xC000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxx_SMIF_S25Hx512T.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08020000" RAMsize="0xC000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CYxx64xx.FLM" start="0x10000000" size="0x000D0000" RAMstart="0x08001800" RAMsize="0x1E800" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08001800" RAMsize="0x1E800" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxx_SMIF_S25Hx512T.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08001800" RAMsize="0x1E800" default="0" style="Keil" />
        <device Dname="CYB06447BZI-BLD53">
          <compile define="CYB06447BZI_BLD53" />
        </device>
        <device Dname="CYB06447BZI-BLD54">
          <compile define="CYB06447BZI_BLD54" />
        </device>
        <device Dname="CYB06447BZI-D54">
          <compile define="CYB06447BZI_D54" />
        </device>
      </subFamily>
      <!-- PSoC 64, CYB06xxA -->
      <subFamily DsubFamily="CYB06xxA">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_02.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_02.svd" />
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40201000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00100000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x001D0000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CYxx64xA.FLM" start="0x10000000" size="0x001D0000" RAMstart="0x080E0000" RAMsize="0xC000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x080E0000" RAMsize="0xC000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SMIF_SFDP.FLM" start="0x18000000" size="0x08000000" RAMstart="0x080E0000" RAMsize="0xC000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CYxx64xA.FLM" start="0x10000000" size="0x001D0000" RAMstart="0x08001800" RAMsize="0xDE800" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08001800" RAMsize="0xDE800" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF_SFDP.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08001800" RAMsize="0xDE800" default="0" style="Keil" />
        <device Dname="CYB0644ABZI-S2D44">
          <compile define="CYB0644ABZI_S2D44" />
        </device>
      </subFamily>
      <!-- PSoC 64, CYS06xxA -->
      <subFamily DsubFamily="CYS06xxA">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_02.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_02.svd" />
        <sequences>
          <sequence name="ResetProcessor" Pname="Cortex-M0p">
            <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
            <block>
              Write32(0x40201000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
            <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
            <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
          </sequence>
        </sequences>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00100000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x001D0000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CYxx64xA.FLM" start="0x10000000" size="0x001D0000" RAMstart="0x080E0000" RAMsize="0xC000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x080E0000" RAMsize="0xC000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SMIF_SFDP.FLM" start="0x18000000" size="0x08000000" RAMstart="0x080E0000" RAMsize="0xC000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CYxx64xA.FLM" start="0x10000000" size="0x001D0000" RAMstart="0x08001800" RAMsize="0xDE800" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_WFLASH.FLM" start="0x14000000" size="0x00008000" RAMstart="0x08001800" RAMsize="0xDE800" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF_SFDP.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08001800" RAMsize="0xDE800" default="0" style="Keil" />
        <device Dname="CYS0644ABZI-S2D44">
          <compile define="CYS0644ABZI_S2D44" />
        </device>
        <device Dname="CYS0644AFNI-S2D43">
          <compile define="CYS0644AFNI_S2D43" />
        </device>
      </subFamily>
    </family>
    <!-- PSoC 4500H -->
    <family Dfamily="PSoC 4500H" Dvendor="Infineon:7">
      <processor Pname="Cortex-M0p" Dcore="Cortex-M0+" DcoreVersion="r0p1" Dfpu="NO_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="100000000" />
      <processor Pname="Cortex-M4" Dcore="Cortex-M4" DcoreVersion="r0p1" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="150000000" />
      <description>PSoC 4500H: Dual-core Cortex-M4/M0+ MCU series with programmable digital and analog peripherals, advanced graphics, CapSense, crypto and secure boot security.</description>
      <debug Pname="Cortex-M0p" __ap="1" defaultResetSequence="ResetProcessor" />
      <debug Pname="Cortex-M4" __ap="2" defaultResetSequence="ResetSystem">
        <datapatch address="0xE008EFE0" value="0x000000A1" info="this is Cortex-M4 TPIU, not Cortex-M3 TPIU. Debuggers may determine by this that TPIU supports Half-Frame Syncs." />
      </debug>
      <book name="README.txt" title="Infineon PSoC 6 DFP user guide" />
      <book name="known_issues.txt" title="Infineon PSoC 6 DFP known issues" />
      <sequences>
        <sequence name="DAP_Handshake">
          <!-- DAP_Handshake: Execute initial handshake sequence depend on selected protocol -->
          <block>
            __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
            __var protType   = __protocol &amp; 0x0000FFFF;
            __var DPIDR = 0;
            __Result = 0;
          </block>
          <!-- JTAG Protocol -->
          <control if="protType == 1">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                DAP_SWJ_Sequence(16, 0xE73C);
              </block>
            </control>
            <block atomic="true">
              // JTAG "Soft" Reset
              DAP_JTAG_Sequence(6, 1, 0x00);                        // Test-Logic-Reset
              // Get IDCODE to make shure that JTAG-DP is available
              DAP_JTAG_Sequence(4, 0, 0x00);                        // 4*Run-Test/Idle
              DAP_JTAG_Sequence(2, 1, 0x00);                        // ~ Select-DR ~ Select-IR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-IR ~ Shift-IR
              DAP_JTAG_Sequence(8, 0, 0xFE);                        // Shift-IR (IDCODE BYPASS)
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-IR (IDCODE BYPASS) ~ Update-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
              DAP_JTAG_Sequence(1, 1, 0x00);                        // Select-DR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-DR ~ Shift-DR
              DPIDR = DAP_JTAG_Sequence(33, 0, 0x00000000);         // Shift 33-bits data
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-DR ~ Update-DR ~ ~ Select-DR ~ Select-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
            </block>
          </control>
          <!-- SWD Protocol -->
          <control if="protType == 2">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E)
                // Change if SWJ-DP uses deprecated switch code (0xEDB6)
                DAP_SWJ_Sequence(16, 0xE79E);
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <control if="!isSWJ">
              <block atomic="true">
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <block>
              DPIDR = ReadDP(0x0); // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
            </block>
          </control>
          <control if="(DPIDR &amp; 0xFFF00FFF) != 0x6BA00477">
            <block>
              __Result = -1; // DAP is unavailable
            </block>
          </control>
        </sequence>
        <sequence name="DAP_poll">
          <!-- DAP_poll: Poll the DAP until it becomes available -->
          <block>
            __Result = -1; // Assume DAP is not available yet
          </block>
          <control while="__Result != 0" timeout="600000">
            <block>
              sequence("DAP_Handshake"); // Poll DP until bootloader allows access to device (can be up to 600ms)
            </block>
          </control>
          <control if="__Result != 0">
            <block>
              Message(1, "The Debug Access Port is unavailable.");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortSetup">
          <!-- DebugPortSetup: Prepare the target debug port for connection -->
          <block>
            sequence("DAP_Handshake");
          </block>
          <control if="__Result != 0">
            <!-- In case DAP isn't avalable, execute a system-wide reset via dedicated debugger reset line. -->
            <block>
              __var nReset      = 0x80;
              __var canReadPins = 0;
              canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
            </block>
            <!-- Keep reset active for 50 ms -->
            <control while="1" timeout="50000" />
            <control if="canReadPins">
              <!-- Assert nRESET line and wait max. 1s for recovery -->
              <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
            </control>
            <control if="!canReadPins">
              <block>
                DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
              </block>
              <!-- Wait 100ms for recovery if nRESET not readable -->
              <control while="1" timeout="100000" />
            </control>
            <block>
              sequence("DAP_poll");
            </block>
          </control>
        </sequence>
        <sequence name="DebugPortStart">
          <!-- DebugPortStart: Connect to the target debug port and power it up -->
          <block info="Read DP CTRL/STAT">
            __var SW_DP_ABORT  = 0x0;
            __var DP_CTRL_STAT = 0x4;
            __var DP_SELECT    = 0x8;
            __var powered_down = 0;
            // Switch to DP Register Bank 0. Explicitly set APSEL to current AP selection
            WriteDP(DP_SELECT, __ap &lt;&lt; 24);
            // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
            powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
          </block>
          <control if="powered_down">
            <block info="Power Up System &amp; Debug">
              // Request Debug/System Power-Up
              // Ignore error here: even there is a polling in the next block, CMSIS-DAP transports reads DP.RDBUFF register
              // right after write to DP.CTRL_STAT. This will fail for some cases - for example if device is waking from DeepSleep.
              __errorcontrol = 1;
              WriteDP(DP_CTRL_STAT, 0x50000000);
              __errorcontrol = 0;
            </block>
            <!-- Wait for Power-Up Request to be acknowledged -->
            <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000" info="Wait for power acknowledged" />
            <!-- CDBGRSTREQ on PSoC6 behaves like Power-On Reset. Not desired when starting the Debug Port
            <block info="Debug Reset">
              __errorcontrol = 1;
              // Request Debug Reset
              WriteDP(DP_CTRL_STAT, 0x54000000);
              // CDBGRSTREQ is equivalent to Power-On Reset and fully reboots the device.
              // Depending on the user application the reboot can take up to 600ms.
              DAP_Delay(600000);
              __errorcontrol = 0;
            </block>
            -->
            <!-- Wait for Debug Reset to be acknowledged, don't issue error on timeout to deal with improperly connected Debug Reset -->
            <!-- <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA8000000) != 0xA8000000" timeout="300000" info="Wait for Debug Reset Acknowledge"/> -->
            <!-- JTAG Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 1">
              <block info="JTAG: Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                WriteDP(DP_CTRL_STAT, 0x50000F32);
              </block>
            </control>
            <!-- SWD Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 2">
              <block info="SWD: Init SWD &amp; Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                WriteDP(DP_CTRL_STAT, 0x50000F00);
                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                WriteDP(SW_DP_ABORT, 0x0000001E);
              </block>
            </control>
          </control>
          <block>
            Sequence("PrintDeviceInfo"); // Print device info
          </block>
        </sequence>
        <sequence name="ResetHardware">
          <!-- ResetHardware: HW Reset causes a reboot of the device which also resets debug.
               - Using this as a prereset is OK to potentially wake up the system from DeepSleep.
               - Using this in the middle of the debug session will break the connection unless recovery
                 from a connection loss is supported by the debug IDE.
          -->
          <block>
            __var nReset      = 0x80;
            __var canReadPins = 0;
            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF); // Deassert nRESET line
          </block>
          <!-- Keep reset active for 50 ms -->
          <control while="1" timeout="50000" />
          <control if="canReadPins">
            <!-- Assert nRESET line and wait max. 1s for recovery -->
            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
          </control>
          <control if="!canReadPins">
            <block>
              DAP_SWJ_Pins(nReset, nReset, 0); // Assert nRESET line
            </block>
            <!-- Wait 100ms for recovery if nRESET not readable -->
            <control while="1" timeout="100000" />
          </control>
          <block>
            // Give the PSoC6 bootloader time to finish (can be up to 600ms)
            DAP_Delay(600000);
          </block>
        </sequence>
        <sequence name="PrintDeviceInfo">
          <!-- PrintDeviceInfo: Read and print device info -->
          <block>
            __var siId;
            __var siRev;
            __var siFamily;
            __var fbVerHi;
            __var sflashSvnVer;
            __var protection;
            __var v;
            Message(0, "****************************************************");
            // Get Si Id, Family and Rev.
            v = Read32(0x16000000);
            siId = (v &amp; 0xFFFF0000) &gt;&gt; 16;
            siRev = (v &amp; 0x0000FF00) &gt;&gt; 8;
            v = Read32(0x1600000C);
            siFamily = v &amp; 0x00000FFF;
            Message(0, "** Silicon: 0x%04X, Family: 0x%03X, Rev.: 0x%02X", siId, siFamily, siRev);
            // Get FlashBboot verison
            fbVerHi = Read32(0x16002004);
          </block>
          <control if="fbVerHi == 0">
            <block>
              Message(1, "Invalid FlashBoot: High version word of Flash Boot is zero");
            </block>
          </control>
          <control if="fbVerHi != 0">
            <block>
              __var fbVerLo = Read32(0x16002018);
              __var b0 = fbVerHi &gt;&gt; 28;
              __var b1 = (fbVerHi &gt;&gt; 24) &amp; 0x0F;
              __var b2 = (fbVerHi &gt;&gt; 16) &amp; 0xFF;
              __var b3 = fbVerHi &amp; 0x0000FFFF;
            </block>
            <control if="b0 &gt; 2">
              <block>
                Message(1, "Unsupported Flash Boot Version - Flash Boot Version [31:28] = 0x%X", b0);
              </block>
            </control>
            <control if="b0 &lt;= 2">
              <control if="b3 != 0x8001">
                <block>
                  Message(1, "Flash Boot is corrupted or non Flash Boot image programmed");
                </block>
              </control>
              <control if="b3 == 0x8001">
                <control if="b0 == 0">
                  <control if="b1 == 1">
                    <block>
                      Message(0, "** Flash Boot version: 1.%02u", b2);
                    </block>
                  </control>
                  <control if="b1 == 2">
                    <control if="b2 &lt; 20">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.0.%u", b2);
                      </block>
                    </control>
                    <control if="(b2 &gt;= 20) &amp;&amp; (b2 &lt; 29)">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.1.%u", b2);
                      </block>
                    </control>
                    <control if="b2 &gt;= 29">
                      <block>
                        Message(0, "** Flash Boot version: 1.20.1.%u", b2);
                      </block>
                    </control>
                  </control>
                </control>
                <control if="b0 == 1">
                  <block>
                    Message(0, "** Flash Boot version: 2.0.0.%u", b2);
                  </block>
                </control>
                <control if="b0 == 2">
                  <block>
                    __var patch = fbVerLo &gt;&gt; 24;
                    __var build = fbVerLo &amp; 0x0000FFFF;
                    Message(0, "** Flash Boot version: %u.%u.%u.%u", b1, b2, patch, build);
                  </block>
                </control>
              </control>
            </control>
          </control>
          <block>
            sflashSvnVer = Read32(0x16000028); // Get SFLASH version
          </block>
          <control if="(sflashSvnVer != 0) &amp;&amp; (sflashSvnVer != 0xFFFFFFFF)">
            <block>
              Message(0, "** SFlash version: %u", sflashSvnVer);
            </block>
          </control>
          <!-- Get life-cycle stage -->
          <control if="siFamily == 0x100">
            <block>
              protection = Read32(0x40210500); // PSoC 6-BLE2 family
            </block>
          </control>
          <control if="siFamily != 0x100">
            <block>
              protection = Read32(0x402020C4); // PSoC 6-2M family
            </block>
          </control>
          <!-- Decode life-cycle stage -->
          <control if="protection == 1">
            <block>
              Message(0, "** Chip Protection: VIRGIN");
            </block>
          </control>
          <control if="protection == 2">
            <block>
              Message(0, "** Chip Protection: NORMAL");
            </block>
          </control>
          <control if="protection == 3">
            <block>
              Message(0, "** Chip Protection: SECURE");
            </block>
          </control>
          <control if="protection == 4">
            <block>
              Message(0, "** Chip Protection: DEAD");
            </block>
          </control>
          <control if="(protection == 0) || (protection &gt; 4)">
            <block>
              Message(0, "** Chip Protection: UNKNOWN");
            </block>
          </control>
          <block>
            Message(0, "****************************************************");
          </block>
        </sequence>
        <sequence name="ResetProcessor" Pname="Cortex-M0p">
          <!-- ResetProcessor: Cortex-M0+ Processor reset via PSoC6 CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
          <block>
              Write32(0x40201000, 0x05FA0000); // Reset CM0+ via "ENABLED" bit in CPUSS_CM0_CTL (M0+ Control Register)
            </block>
          <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
          <control while="(Read32(0xE000EDF0) &amp; 0x02000000)" timeout="500000" />
        </sequence>
        <sequence name="ResetSystem" Pname="Cortex-M0p">
          <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x40201120);
            vtBase = vtBase &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; ((vtBase &amp; 0xFFFF0000) != 0xFFFF0000);
          </block>
          <control if="appValid">
            <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
            <control if="resetAddress">
              <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);
                
                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);
                
                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;
                
                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);
                
                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
              </block>
              <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
              <block>
                __errorcontrol = 0;
              </block>
            </control>
          </control>
        </sequence>
        <sequence name="DebugCoreStart" Pname="Cortex-M4">
          <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
          <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
          <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
            <block>
              Sequence("SetupTraceClock");
            </block>
          </control>
        </sequence>
        <!-- Configure pins trace pins if Parallel Trace Port enabled -->
        <sequence name="TraceStart" Pname="Cortex-M4">
          <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
            <block>
              __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
            </block>
            <control if="__TPIU_pinlocation == 1" info="CY8CKIT-062-WIFI-BT Like">
              <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
              <control if="tpWidth &gt;= 1">
                <block>
                  sequence("SetupTracePin_P7_6");
                </block>
              </control>
              <control if="tpWidth &gt;= 2">
                <block>
                  sequence("SetupTracePin_P7_5");
                  sequence("SetupTracePin_P7_4");
                </block>
              </control>
            </control>
            <control if="__TPIU_pinlocation == 2" info="CY8CKIT-062S2-43012 Like">
              <block>
                sequence("SetupTracePin_P7_0");
                sequence("SetupTracePin_P9_3");
              </block>
              <control if="tpWidth &gt;= 1">
                <block>
                  sequence("SetupTracePin_P9_2");
                </block>
              </control>
              <control if="tpWidth &gt;= 2">
                <block>
                  sequence("SetupTracePin_P9_1");
                  sequence("SetupTracePin_P9_0");
                </block>
              </control>
            </control>
          </control>
        </sequence>
        <sequence name="SetupTraceClock" Pname="Cortex-M4">
          <block>
            __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;    // PERI_CLOCK_CTL.DIV_SEL
            __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;       // ENABLE field in PERI_DIV_CMD
            __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;      // DISABLE field in PERI_DIV_CMD
            // Peripheral clock divider index to use for trace clock
            __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
            __var ClockDivVal = 0 &amp; PERI_DIV_PA_SEL_MASK;  // Peripheral clock divider value for trace clock
                                                               // Actual divider is (1+ClockDivVal)
            __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
            __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
          </block>
          <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
            <block>
              Message(0, "Setup TPIU clock");
              // DISABLE 8.0 DIV in PERI_DIV_CMD:
              __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              // Use selected divider (8.0) for cpuss.clock_trace_in
              Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
              // Set 8.0 DIV = ClockDivVal
              Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
              // ENABLE 8.0 DIV
              ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
              Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_0 as TRACECLK -->
        <sequence name="SetupTracePin_P7_0" Pname="Cortex-M4">
          <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1A;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P7_0)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACECLK to P7_0");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_4 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P7_4" Pname="Cortex-M4">
          <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P7_4");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_5 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P7_5" Pname="Cortex-M4">
          <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P7_5");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P7_6 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P7_6" Pname="Cortex-M4">
          <block>
            __var pin = 6;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt7PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt7CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt7CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt7CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P7_6");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_0 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P9_0" Pname="Cortex-M4">
          <block>
            __var pin = 0;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P9_0");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_1 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P9_1" Pname="Cortex-M4">
          <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P9_1");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_2 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P9_2" Pname="Cortex-M4">
          <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P9_2");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P9_3 as TRACEDATA[0]  -->
        <sequence name="SetupTracePin_P9_3" Pname="Cortex-M4">
          <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P7, P9 and P10)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt9PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt9CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt9CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt9CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[0] to P9_3");
            </block>
          </control>
        </sequence>
      </sequences>
      <!-- PSoC 4500H, CY8C6xx4 -->
      <subFamily DsubFamily="CY8C6xx4">
        <debug Pname="Cortex-M0p" svd="SVD/psoc6_04.svd" />
        <debug Pname="Cortex-M4" svd="SVD/psoc6_04.svd" />
        <debugvars configfile="Debug/CY8C6xxA.dbgconf" version="1.0">
          __var __TPIU_pinlocation = 2;  // Select one of the possible TPIU pin locations
          // TraceClock configuration data
          __var TRACE_CLOCK_CTL_ADDR = 0x40000C54;           // Clock control register for cpuss.clock_trace_in
          __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40001000;       // Divider control (for 8.0 divider)
          __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40000400;       // Divider command
          __var PERI_CLOCK_CTL_DIV_SEL = 0x03;               // 512K devices have 4 of 8-bit dividers - use the lastest available for tracing
          __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
          __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
          // TPIU pins configuration data, IOSS V2
          __var hsiomPrt7PortSel0Addr = 0x40300070;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 7 selection 0
          __var hsiomPrt9PortSel0Addr = 0x40300090;  // HSIOM_PRT[port]_PORT_SEL0Â·registerÂ·address. Port 9 selection 0
          __var gpioPrt7CfgAddr = 0x403103C4;        // GPIO_PRT[port]_CFG register address. Port 7 configuration
          __var gpioPrt9CfgAddr = 0x403104C4;        // GPIO_PRT[port]_CFG register address. Port 9 configuration
          __var gpioPrt7CfgOutAddr = 0x403103CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 7 output buffer configuration
          __var gpioPrt9CfgOutAddr = 0x403104CC;     // GPIO_PRT[port]_CFG_OUT register address. Port 9 output buffer configuration
        </debugvars>
        <memory name="IRAM1" access="rwx" start="0x08000000" size="0x00020000" default="1" />
        <memory name="IROM1" access="rx" start="0x10000000" size="0x00040000" default="1" startup="1" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx4.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xx4_sect128KB.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M0p" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx4.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xx4_sect128KB.FLM" start="0x10000000" size="0x00040000" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_USER.FLM" start="0x16000800" size="0x00000800" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_NAR.FLM" start="0x16001A00" size="0x00000200" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_PKEY.FLM" start="0x16005A00" size="0x00000C00" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SFLASH_TOC2.FLM" start="0x16007C00" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="1" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_SMIF.FLM" start="0x18000000" size="0x08000000" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <algorithm Pname="Cortex-M4" name="Flash/CY8C6xxA_EFUSE.FLM" start="0x90700000" size="0x00000400" RAMstart="0x08002400" RAMsize="0x8000" default="0" style="Keil" />
        <device Dname="CY8C4588AZI-H675">
          <compile define="CY8C4588AZI_H675" />
        </device>
        <device Dname="CY8C4588AZI-H676">
          <compile define="CY8C4588AZI_H676" />
        </device>
        <device Dname="CY8C4588AZI-H685">
          <compile define="CY8C4588AZI_H685" />
        </device>
        <device Dname="CY8C4588AZI-H686">
          <compile define="CY8C4588AZI_H686" />
        </device>
        <device Dname="CY8C4588AZQ-H685">
          <compile define="CY8C4588AZQ_H685" />
        </device>
        <device Dname="CY8C4588AZQ-H686">
          <compile define="CY8C4588AZQ_H686" />
        </device>
      </subFamily>
    </family>
  </devices>
  <conditions>
    <condition id="PSoC 6">
      <description>PSoC 6 devices</description>
      <accept condition="PSoC 60" />
      <accept condition="PSoC 61" />
      <accept condition="PSoC 62" />
      <accept condition="PSoC 63" />
      <accept condition="PSoC 64" />
      <accept condition="PSoC 4500H" />
      <require Cclass="Device" Cgroup="Startup" />
    </condition>
    <condition id="PSoC 60">
      <description>PSoC 60 devices</description>
      <accept Dvendor="Infineon:7" Dname="CY8C6016BZI-F04" />
      <accept Dvendor="Infineon:7" Dname="CY8C6036BZI-F04" />
    </condition>
    <condition id="PSoC 61">
      <description>PSoC 61 devices</description>
      <accept Dvendor="Infineon:7" Dname="CY8C6144AZI-S4F12" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144AZI-S4F62" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144AZI-S4F82" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144AZI-S4F83" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144AZI-S4F92" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144AZI-S4F93" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144AZQ-S4F92" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144AZQ-S4F93" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144LQI-S4F12" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144LQI-S4F62" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144LQI-S4F82" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144LQI-S4F92" />
      <accept Dvendor="Infineon:7" Dname="CY8C6144LQQ-S4F92" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145AZI-S3F02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145AZI-S3F12" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145AZI-S3F42" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145AZI-S3F62" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145AZI-S3F72" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145FNI-S3F11" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145FNI-S3F41" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145FNI-S3F71" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145LQI-S3F02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145LQI-S3F12" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145LQI-S3F42" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145LQI-S3F62" />
      <accept Dvendor="Infineon:7" Dname="CY8C6145LQI-S3F72" />
      <accept Dvendor="Infineon:7" Dname="CY8C6116BZI-F54" />
      <accept Dvendor="Infineon:7" Dname="CY8C6136BZI-F14" />
      <accept Dvendor="Infineon:7" Dname="CY8C6136BZI-F34" />
      <accept Dvendor="Infineon:7" Dname="CY8C6136FDI-F42" />
      <accept Dvendor="Infineon:7" Dname="CY8C6136FTI-F42" />
      <accept Dvendor="Infineon:7" Dname="CY8C6117BZI-F34" />
      <accept Dvendor="Infineon:7" Dname="CY8C6117FDI-F02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6117WI-F34" />
      <accept Dvendor="Infineon:7" Dname="CY8C6137BZI-F14" />
      <accept Dvendor="Infineon:7" Dname="CY8C6137BZI-F34" />
      <accept Dvendor="Infineon:7" Dname="CY8C6137BZI-F54" />
      <accept Dvendor="Infineon:7" Dname="CY8C6137FDI-F02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6137WI-F54" />
      <accept Dvendor="Infineon:7" Dname="CY8C6148AZI-S2F44" />
      <accept Dvendor="Infineon:7" Dname="CY8C6148BZI-S2F44" />
      <accept Dvendor="Infineon:7" Dname="CY8C6148FNI-S2F43" />
      <accept Dvendor="Infineon:7" Dname="CY8C6148LQI-S2F02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6148LQI-S2F42" />
      <accept Dvendor="Infineon:7" Dname="CY8C614AAZI-S2F04" />
      <accept Dvendor="Infineon:7" Dname="CY8C614AAZI-S2F14" />
      <accept Dvendor="Infineon:7" Dname="CY8C614AAZI-S2F44" />
      <accept Dvendor="Infineon:7" Dname="CY8C614ABZI-S2F04" />
      <accept Dvendor="Infineon:7" Dname="CY8C614ABZI-S2F44" />
      <accept Dvendor="Infineon:7" Dname="CY8C614AFNI-S2F03" />
      <accept Dvendor="Infineon:7" Dname="CY8C614AFNI-S2F43" />
      <accept Dvendor="Infineon:7" Dname="CY8C614ALQI-S2F02" />
      <accept Dvendor="Infineon:7" Dname="CY8C614ALQI-S2F42" />
    </condition>
    <condition id="PSoC 62">
      <description>PSoC 62 devices</description>
      <accept Dvendor="Infineon:7" Dname="CY8C6244AZI-S4D12" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244AZI-S4D62" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244AZI-S4D82" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244AZI-S4D83" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244AZI-S4D92" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244AZI-S4D93" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244AZQ-S4D92" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244AZQ-S4D93" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244LQI-S4D12" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244LQI-S4D62" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244LQI-S4D82" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244LQI-S4D92" />
      <accept Dvendor="Infineon:7" Dname="CY8C6244LQQ-S4D92" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245AZI-S3D02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245AZI-S3D12" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245AZI-S3D42" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245AZI-S3D62" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245AZI-S3D72" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245FNI-S3D11" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245FNI-S3D41" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245FNI-S3D71" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245LQI-S3D02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245LQI-S3D12" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245LQI-S3D42" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245LQI-S3D62" />
      <accept Dvendor="Infineon:7" Dname="CY8C6245LQI-S3D72" />
      <accept Dvendor="Infineon:7" Dname="CY8C6246BZI-D04" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247BFI-D54" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247BZI-AUD54" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247BZI-D34" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247BZI-D44" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247BZI-D54" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247FDI-D02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247FDI-D32" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247FDI-D52" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247FTI-D52" />
      <accept Dvendor="Infineon:7" Dname="CY8C6247WI-D54" />
      <accept Dvendor="Infineon:7" Dname="CY8C6248AZI-S2D14" />
      <accept Dvendor="Infineon:7" Dname="CY8C6248AZI-S2D44" />
      <accept Dvendor="Infineon:7" Dname="CY8C6248BZI-S2D44" />
      <accept Dvendor="Infineon:7" Dname="CY8C6248FNI-S2D43" />
      <accept Dvendor="Infineon:7" Dname="CY8C6248LQI-S2D02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6248LQI-S2D42" />
      <accept Dvendor="Infineon:7" Dname="CY8C624AAZI-S2D14" />
      <accept Dvendor="Infineon:7" Dname="CY8C624AAZI-S2D44" />
      <accept Dvendor="Infineon:7" Dname="CY8C624ABZI-D44" />
      <accept Dvendor="Infineon:7" Dname="CY8C624ABZI-S2D04" />
      <accept Dvendor="Infineon:7" Dname="CY8C624ABZI-S2D14" />
      <accept Dvendor="Infineon:7" Dname="CY8C624ABZI-S2D44" />
      <accept Dvendor="Infineon:7" Dname="CY8C624ABZI-S2D44A0" />
      <accept Dvendor="Infineon:7" Dname="CY8C624AFNI-S2D43" />
      <accept Dvendor="Infineon:7" Dname="CY8C624ALQI-S2D02" />
      <accept Dvendor="Infineon:7" Dname="CY8C624ALQI-S2D42" />
    </condition>
    <condition id="PSoC 63">
      <description>PSoC 63 devices</description>
      <accept Dvendor="Infineon:7" Dname="CY8C6316BZI-BLF03" />
      <accept Dvendor="Infineon:7" Dname="CY8C6316BZI-BLF04" />
      <accept Dvendor="Infineon:7" Dname="CY8C6316BZI-BLF53" />
      <accept Dvendor="Infineon:7" Dname="CY8C6316BZI-BLF54" />
      <accept Dvendor="Infineon:7" Dname="CY8C6336BZI-BLD13" />
      <accept Dvendor="Infineon:7" Dname="CY8C6336BZI-BLD14" />
      <accept Dvendor="Infineon:7" Dname="CY8C6336BZI-BLF03" />
      <accept Dvendor="Infineon:7" Dname="CY8C6336BZI-BLF04" />
      <accept Dvendor="Infineon:7" Dname="CY8C6336LQI-BLF02" />
      <accept Dvendor="Infineon:7" Dname="CY8C6336LQI-BLF42" />
      <accept Dvendor="Infineon:7" Dname="CY8C6337BZI-BLF13" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347BZI-BLD33" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347BZI-BLD34" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347BZI-BLD43" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347BZI-BLD44" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347BZI-BLD53" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347BZI-BLD54" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347FMI-BLD13" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347FMI-BLD33" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347FMI-BLD43" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347FMI-BLD53" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347FMI-BUD13" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347FMI-BUD33" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347FMI-BUD43" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347FMI-BUD53" />
      <accept Dvendor="Infineon:7" Dname="CY8C6347LQI-BLD52" />
      <accept Dvendor="Infineon:7" Dname="CYBLE-416045-02" />
    </condition>
    <condition id="PSoC 64">
      <description>PSoC 64 devices</description>
      <accept Dvendor="Infineon:7" Dname="CYB06445LQI-S3D42" />
      <accept Dvendor="Infineon:7" Dname="CYB06447BZI-BLD53" />
      <accept Dvendor="Infineon:7" Dname="CYB06447BZI-BLD54" />
      <accept Dvendor="Infineon:7" Dname="CYB06447BZI-D54" />
      <accept Dvendor="Infineon:7" Dname="CYB0644ABZI-S2D44" />
      <accept Dvendor="Infineon:7" Dname="CYS0644ABZI-S2D44" />
      <accept Dvendor="Infineon:7" Dname="CYS0644AFNI-S2D43" />
    </condition>
    <condition id="PSoC 4500H">
      <description>PSoC 4500H devices</description>
      <accept Dvendor="Infineon:7" Dname="CY8C4588AZI-H675" />
      <accept Dvendor="Infineon:7" Dname="CY8C4588AZI-H676" />
      <accept Dvendor="Infineon:7" Dname="CY8C4588AZI-H685" />
      <accept Dvendor="Infineon:7" Dname="CY8C4588AZI-H686" />
      <accept Dvendor="Infineon:7" Dname="CY8C4588AZQ-H685" />
      <accept Dvendor="Infineon:7" Dname="CY8C4588AZQ-H686" />
    </condition>
  </conditions>
  <components>
    <component Cclass="Device" Cgroup="Startup" Cversion="1.0.0" condition="PSoC 6">
      <!-- This is a dummy startup implementation that emits a compiler error once
           this software component is enabled in the CMSIS RTE project configuration.
           It exists to silence PackChk WARNING M350: No 'Startup' component found.
           Refer to README.txt in the pack root directory for the guidance on the
           intended use of this CSMIS pack. -->
      <description>Dummy startup component, do not use</description>
      <files>
        <file category="doc" name="README.txt" />
        <file category="source" name="Device/Source/startup_error.c" version="1.0.0" />
      </files>
    </component>
  </components>
</package>